/**
 * Slice.js Bundle
 * Type: route
 * Generated: 2026-02-09T23:50:54.646Z
 * Strategy: hybrid
 * Components: 16
 * Total Size: 1601.7 KB
 */

export const SLICE_BUNDLE = {
  metadata: {
  "version": "2.0.0",
  "type": "route",
  "route": "advanced",
  "generated": "2026-02-09T23:50:54.646Z",
  "totalSize": 1640155,
  "componentCount": 16,
  "strategy": "hybrid"
},

  components: {
  "StructuralDocumentation": {
    "name": "StructuralDocumentation",
    "category": "AppComponents",
    "categoryType": "Visual",
    "js": "class StructuralDocumentation extends HTMLElement {\n  constructor(props) {\n    super();\n    slice.attachTemplate(this);\n    slice.controller.setComponentProps(this, props);\n    this.debuggerProps = [];\n  }\n\n  async init() {\n    this.markdownPath = \"getting-started/structural-components.md\";\n    this.markdownContent = \"---\\ntitle: Structural\\nroute: /Documentation/Structural\\nnavLabel: Structural\\nsection: Getting Started\\ngroup: Components\\norder: 33\\ndescription: Structural components that power Slice.js.\\ncomponent: StructuralDocumentation\\ntags: [structural, controller, router, styles]\\n---\\n\\n# Structural Components\\n\\n## Overview\\nStructural components power the framework runtime. They are created by Slice.js and exposed\\nunder `slice.*`. You do not build them directly.\\n\\n## Key Components\\n- `slice.controller` for component lifecycle and lookup\\n- `slice.router` for navigation and route rendering\\n- `slice.stylesManager` for styles and themes\\n- `slice.events` for pub/sub (optional)\\n- `slice.context` for shared state (optional)\\n\\n## Controller API\\n| Method | Signature | Returns | Notes |\\n| --- | --- | --- | --- |\\n| `getComponent` | `(sliceId)` | `HTMLElement | undefined` | Lookup by sliceId. |\\n| `destroyByContainer` | `(container)` | `number` | Destroys Slice components inside container. |\\n| `destroyByPattern` | `(pattern)` | `number` | Destroys components whose sliceId matches pattern. |\\n\\n```javascript title=\\\"Destroy components safely\\\"\\nconst container = this.querySelector('.items');\\nslice.controller.destroyByContainer(container);\\ncontainer.innerHTML = '';\\n```\\n\\n## Router API\\n| Method | Signature | Notes |\\n| --- | --- | --- |\\n| `navigate` | `(path, _redirectChain?, _options?)` | Programmatic navigation. |\\n| `beforeEach` | `(to, from, next)` | Register a guard before navigation. |\\n| `afterEach` | `(to, from)` | Run logic after navigation. |\\n| `start` | `()` | Start routing immediately. |\\n\\n## Styles and Themes\\n`slice.setTheme(themeName)` applies a theme through the StylesManager.\\n\\n```javascript title=\\\"Switch themes\\\"\\nawait slice.setTheme('Dark');\\n```\\n\\n## EventManager (Optional)\\nProvides pub/sub via `slice.events`. When disabled, the API is a no-op.\\n\\n| Method | Signature | Notes |\\n| --- | --- | --- |\\n| `subscribe` | `(eventName, callback, options?)` | Returns subscription id. |\\n| `subscribeOnce` | `(eventName, callback, options?)` | Auto-unsubscribe after first emit. |\\n| `unsubscribe` | `(eventName, id)` | Returns boolean. |\\n| `emit` | `(eventName, data?)` | Emits to all subscribers. |\\n| `bind` | `(component)` | Returns component-bound API. |\\n\\n## ContextManager (Optional)\\nShared state system available at `slice.context`.\\n\\n| Method | Signature | Notes |\\n| --- | --- | --- |\\n| `create` | `(name, initialState, options?)` | Options include `persist`. |\\n| `getState` | `(name)` | Returns current state or null. |\\n| `setState` | `(name, updater)` | Accepts object or updater function. |\\n| `watch` | `(name, component, callback, selector?)` | Auto-cleanup via component. |\\n| `destroy` | `(name)` | Removes a context. |\\n| `list` | `()` | Returns context names. |\\n\\n## Best Practices\\n:::tip\\nUse `destroyByContainer` before recreating dynamic lists to avoid leaks.\\n:::\\n\\n:::tip\\nRegister guards before calling `slice.router.start()`.\\n:::\\n\";\n    if (true) {\n      this.setupCopyButton();\n    }\n      {\n         const container = this.querySelector('[data-block-id=\"doc-block-1\"]');\n         if (container) {\n            const lines = [\"| Method | Signature | Returns | Notes |\",\"| --- | --- | --- | --- |\",\"| `getComponent` | `(sliceId)` | `HTMLElement | undefined` | Lookup by sliceId. |\",\"| `destroyByContainer` | `(container)` | `number` | Destroys Slice components inside container. |\",\"| `destroyByPattern` | `(pattern)` | `number` | Destroys components whose sliceId matches pattern. |\"];\n            const clean = (line) => {\n               let value = line.trim();\n               if (value.startsWith('|')) {\n                  value = value.slice(1);\n               }\n               if (value.endsWith('|')) {\n                  value = value.slice(0, -1);\n               }\n               return value.split('|').map((cell) => cell.trim());\n            };\n\n            const formatCell = (text) => {\n               let output = text\n                  .replace(/&/g, '&amp;')\n                  .replace(/</g, '&lt;')\n                  .replace(/>/g, '&gt;');\n\n               const applyBold = (input) => {\n                  let result = '';\n                  let index = 0;\n                  while (index < input.length) {\n                     const start = input.indexOf('**', index);\n                     if (start === -1) {\n                        result += input.slice(index);\n                        break;\n                     }\n                     const end = input.indexOf('**', start + 2);\n                     if (end === -1) {\n                        result += input.slice(index);\n                        break;\n                     }\n                     result += input.slice(index, start) + '<strong>' + input.slice(start + 2, end) + '</strong>';\n                     index = end + 2;\n                  }\n                  return result;\n               };\n\n               const applyInlineCode = (input) => {\n                  const parts = input.split(String.fromCharCode(96));\n                  if (parts.length === 1) return input;\n                  return parts\n                     .map((part, idx) => (idx % 2 === 1 ? '<code>' + part + '</code>' : part))\n                     .join('');\n               };\n\n               output = applyBold(output);\n               output = applyInlineCode(output);\n               return output;\n            };\n\n            const headers = lines.length > 0 ? clean(lines[0]) : [];\n            const rows = lines.slice(2).map((line) => clean(line).map((cell) => formatCell(cell)));\n            const table = await slice.build('Table', { headers, rows });\n            container.appendChild(table);\n         }\n      }\n      {\n         const container = this.querySelector('[data-block-id=\"doc-block-2\"]');\n         if (container) {\n            const code = await slice.build('CodeVisualizer', {\n               value: \"const container = this.querySelector('.items');\\nslice.controller.destroyByContainer(container);\\ncontainer.innerHTML = '';\",\n               language: \"javascript\"\n            });\n            if (\"Destroy components safely\") {\n               const label = document.createElement('div');\n               label.classList.add('code-block-title');\n               label.textContent = \"Destroy components safely\";\n               container.appendChild(label);\n            }\n            container.appendChild(code);\n         }\n      }\n      {\n         const container = this.querySelector('[data-block-id=\"doc-block-3\"]');\n         if (container) {\n            const lines = [\"| Method | Signature | Notes |\",\"| --- | --- | --- |\",\"| `navigate` | `(path, _redirectChain?, _options?)` | Programmatic navigation. |\",\"| `beforeEach` | `(to, from, next)` | Register a guard before navigation. |\",\"| `afterEach` | `(to, from)` | Run logic after navigation. |\",\"| `start` | `()` | Start routing immediately. |\"];\n            const clean = (line) => {\n               let value = line.trim();\n               if (value.startsWith('|')) {\n                  value = value.slice(1);\n               }\n               if (value.endsWith('|')) {\n                  value = value.slice(0, -1);\n               }\n               return value.split('|').map((cell) => cell.trim());\n            };\n\n            const formatCell = (text) => {\n               let output = text\n                  .replace(/&/g, '&amp;')\n                  .replace(/</g, '&lt;')\n                  .replace(/>/g, '&gt;');\n\n               const applyBold = (input) => {\n                  let result = '';\n                  let index = 0;\n                  while (index < input.length) {\n                     const start = input.indexOf('**', index);\n                     if (start === -1) {\n                        result += input.slice(index);\n                        break;\n                     }\n                     const end = input.indexOf('**', start + 2);\n                     if (end === -1) {\n                        result += input.slice(index);\n                        break;\n                     }\n                     result += input.slice(index, start) + '<strong>' + input.slice(start + 2, end) + '</strong>';\n                     index = end + 2;\n                  }\n                  return result;\n               };\n\n               const applyInlineCode = (input) => {\n                  const parts = input.split(String.fromCharCode(96));\n                  if (parts.length === 1) return input;\n                  return parts\n                     .map((part, idx) => (idx % 2 === 1 ? '<code>' + part + '</code>' : part))\n                     .join('');\n               };\n\n               output = applyBold(output);\n               output = applyInlineCode(output);\n               return output;\n            };\n\n            const headers = lines.length > 0 ? clean(lines[0]) : [];\n            const rows = lines.slice(2).map((line) => clean(line).map((cell) => formatCell(cell)));\n            const table = await slice.build('Table', { headers, rows });\n            container.appendChild(table);\n         }\n      }\n      {\n         const container = this.querySelector('[data-block-id=\"doc-block-4\"]');\n         if (container) {\n            const code = await slice.build('CodeVisualizer', {\n               value: \"await slice.setTheme('Dark');\",\n               language: \"javascript\"\n            });\n            if (\"Switch themes\") {\n               const label = document.createElement('div');\n               label.classList.add('code-block-title');\n               label.textContent = \"Switch themes\";\n               container.appendChild(label);\n            }\n            container.appendChild(code);\n         }\n      }\n      {\n         const container = this.querySelector('[data-block-id=\"doc-block-5\"]');\n         if (container) {\n            const lines = [\"| Method | Signature | Notes |\",\"| --- | --- | --- |\",\"| `subscribe` | `(eventName, callback, options?)` | Returns subscription id. |\",\"| `subscribeOnce` | `(eventName, callback, options?)` | Auto-unsubscribe after first emit. |\",\"| `unsubscribe` | `(eventName, id)` | Returns boolean. |\",\"| `emit` | `(eventName, data?)` | Emits to all subscribers. |\",\"| `bind` | `(component)` | Returns component-bound API. |\"];\n            const clean = (line) => {\n               let value = line.trim();\n               if (value.startsWith('|')) {\n                  value = value.slice(1);\n               }\n               if (value.endsWith('|')) {\n                  value = value.slice(0, -1);\n               }\n               return value.split('|').map((cell) => cell.trim());\n            };\n\n            const formatCell = (text) => {\n               let output = text\n                  .replace(/&/g, '&amp;')\n                  .replace(/</g, '&lt;')\n                  .replace(/>/g, '&gt;');\n\n               const applyBold = (input) => {\n                  let result = '';\n                  let index = 0;\n                  while (index < input.length) {\n                     const start = input.indexOf('**', index);\n                     if (start === -1) {\n                        result += input.slice(index);\n                        break;\n                     }\n                     const end = input.indexOf('**', start + 2);\n                     if (end === -1) {\n                        result += input.slice(index);\n                        break;\n                     }\n                     result += input.slice(index, start) + '<strong>' + input.slice(start + 2, end) + '</strong>';\n                     index = end + 2;\n                  }\n                  return result;\n               };\n\n               const applyInlineCode = (input) => {\n                  const parts = input.split(String.fromCharCode(96));\n                  if (parts.length === 1) return input;\n                  return parts\n                     .map((part, idx) => (idx % 2 === 1 ? '<code>' + part + '</code>' : part))\n                     .join('');\n               };\n\n               output = applyBold(output);\n               output = applyInlineCode(output);\n               return output;\n            };\n\n            const headers = lines.length > 0 ? clean(lines[0]) : [];\n            const rows = lines.slice(2).map((line) => clean(line).map((cell) => formatCell(cell)));\n            const table = await slice.build('Table', { headers, rows });\n            container.appendChild(table);\n         }\n      }\n      {\n         const container = this.querySelector('[data-block-id=\"doc-block-6\"]');\n         if (container) {\n            const lines = [\"| Method | Signature | Notes |\",\"| --- | --- | --- |\",\"| `create` | `(name, initialState, options?)` | Options include `persist`. |\",\"| `getState` | `(name)` | Returns current state or null. |\",\"| `setState` | `(name, updater)` | Accepts object or updater function. |\",\"| `watch` | `(name, component, callback, selector?)` | Auto-cleanup via component. |\",\"| `destroy` | `(name)` | Removes a context. |\",\"| `list` | `()` | Returns context names. |\"];\n            const clean = (line) => {\n               let value = line.trim();\n               if (value.startsWith('|')) {\n                  value = value.slice(1);\n               }\n               if (value.endsWith('|')) {\n                  value = value.slice(0, -1);\n               }\n               return value.split('|').map((cell) => cell.trim());\n            };\n\n            const formatCell = (text) => {\n               let output = text\n                  .replace(/&/g, '&amp;')\n                  .replace(/</g, '&lt;')\n                  .replace(/>/g, '&gt;');\n\n               const applyBold = (input) => {\n                  let result = '';\n                  let index = 0;\n                  while (index < input.length) {\n                     const start = input.indexOf('**', index);\n                     if (start === -1) {\n                        result += input.slice(index);\n                        break;\n                     }\n                     const end = input.indexOf('**', start + 2);\n                     if (end === -1) {\n                        result += input.slice(index);\n                        break;\n                     }\n                     result += input.slice(index, start) + '<strong>' + input.slice(start + 2, end) + '</strong>';\n                     index = end + 2;\n                  }\n                  return result;\n               };\n\n               const applyInlineCode = (input) => {\n                  const parts = input.split(String.fromCharCode(96));\n                  if (parts.length === 1) return input;\n                  return parts\n                     .map((part, idx) => (idx % 2 === 1 ? '<code>' + part + '</code>' : part))\n                     .join('');\n               };\n\n               output = applyBold(output);\n               output = applyInlineCode(output);\n               return output;\n            };\n\n            const headers = lines.length > 0 ? clean(lines[0]) : [];\n            const rows = lines.slice(2).map((line) => clean(line).map((cell) => formatCell(cell)));\n            const table = await slice.build('Table', { headers, rows });\n            container.appendChild(table);\n         }\n      }\n  }\n\n  async update() {\n    // Refresh dynamic content here if needed\n  }\n\n  beforeDestroy() {\n    // Cleanup timers, listeners, or pending work here\n  }\n\n  async setupCopyButton() {\n    const container = this.querySelector('[data-copy-md]');\n    if (!container) return;\n\n    const copyMenu = await slice.build('CopyMarkdownMenu', {\n      markdownPath: this.markdownPath,\n      markdownContent: this.markdownContent,\n      label: '❐'\n    });\n\n    container.appendChild(copyMenu);\n  }\n\n  async copyMarkdown() {}\n}\n\nwindow.StructuralDocumentation = StructuralDocumentation;\ncustomElements.define('slice-structuraldocumentation', StructuralDocumentation);\n\nreturn StructuralDocumentation;",
    "externalDependencies": {},
    "componentDependencies": [
      "Table",
      "CodeVisualizer",
      "CopyMarkdownMenu"
    ],
    "html": "<div class=\"documentation-content structuraldocumentation\">\n\n<div class=\"doc-title-bar\">\n  <h1 id=\"structural-components\">\n    <span class=\"doc-title-text\">Structural Components</span>\n    <span class=\"copy-md-slot\" data-copy-md></span>\n  </h1>\n</div>\n<h2 id=\"overview\">Overview</h2>\n<p>Structural components power the framework runtime. They are created by Slice.js and exposed under <code>slice.*</code>. You do not build them directly.</p>\n<h2 id=\"key-components\">Key Components</h2>\n<ul><li><code>slice.controller</code> for component lifecycle and lookup</li><li><code>slice.router</code> for navigation and route rendering</li><li><code>slice.stylesManager</code> for styles and themes</li><li><code>slice.events</code> for pub/sub (optional)</li><li><code>slice.context</code> for shared state (optional)</li></ul>\n<h2 id=\"controller-api\">Controller API</h2>\n<div class=\"table-block\" data-block-id=\"doc-block-1\"></div>\n<div class=\"code-block\" data-block-id=\"doc-block-2\"></div>\n<h2 id=\"router-api\">Router API</h2>\n<div class=\"table-block\" data-block-id=\"doc-block-3\"></div>\n<h2 id=\"styles-and-themes\">Styles and Themes</h2>\n<p><code>slice.setTheme(themeName)</code> applies a theme through the StylesManager.</p>\n<div class=\"code-block\" data-block-id=\"doc-block-4\"></div>\n<h2 id=\"eventmanager-optional\">EventManager (Optional)</h2>\n<p>Provides pub/sub via <code>slice.events</code>. When disabled, the API is a no-op.</p>\n<div class=\"table-block\" data-block-id=\"doc-block-5\"></div>\n<h2 id=\"contextmanager-optional\">ContextManager (Optional)</h2>\n<p>Shared state system available at <code>slice.context</code>.</p>\n<div class=\"table-block\" data-block-id=\"doc-block-6\"></div>\n<h2 id=\"best-practices\">Best Practices</h2>\n<div class=\"callout callout-tip\">Use <code>destroyByContainer</code> before recreating dynamic lists to avoid leaks.</div>\n<div class=\"callout callout-tip\">Register guards before calling <code>slice.router.start()</code>.</div>\n</div>\n",
    "css": "slice-structuraldocumentation {\r\n  color: var(--font-primary-color);\r\n  font-family: var(--font-family);\r\n}\r\n\r\nslice-structuraldocumentation h1,\r\nslice-structuraldocumentation h2,\r\nslice-structuraldocumentation h3 {\r\n  margin-top: 1.5em;\r\n  margin-bottom: 0.5em;\r\n}\r\n\r\nslice-structuraldocumentation p {\r\n  line-height: 1.6;\r\n  margin: 1em 0;\r\n}\r\n\r\nslice-structuraldocumentation ul,\r\nslice-structuraldocumentation ol {\r\n  margin: 1em 0;\r\n  padding-left: 2em;\r\n}\r\n\r\nslice-structuraldocumentation li {\r\n  margin-bottom: 0.5em;\r\n}\r\n\r\nslice-structuraldocumentation code {\r\n  font-family: monospace;\r\n  background-color: var(--secondary-background-color);\r\n  padding: 0.2em 0.4em;\r\n  border-radius: 3px;\r\n  font-size: 0.9em;\r\n}\r\n\r\nslice-structuraldocumentation .controller-example,\nslice-structuraldocumentation .controller-destroy-example,\nslice-structuraldocumentation .router-example,\nslice-structuraldocumentation .styles-manager-example,\nslice-structuraldocumentation .logger-example,\nslice-structuraldocumentation .debugger-example {\n   margin: 1.5em 0;\n}\n\r\nslice-structuraldocumentation strong {\r\n  color: var(--primary-color);\r\n}\r\n\r\nslice-structuraldocumentation .faq-section {\r\n  margin: 2em 0;\r\n}\r\n\r\nslice-structuraldocumentation .faq-section slice-details {\r\n  margin-bottom: 1em;\r\n}\r\n\r\nslice-structuraldocumentation h2 {\r\n  border-bottom: 1px solid var(--primary-color-shade);\r\n  padding-bottom: 0.3em;\r\n}\r\n\r\nslice-structuraldocumentation h3 {\r\n  color: var(--primary-color);\r\n}\r\n\r\nslice-structuraldocumentation .structural-component {\r\n  border-left: 3px solid var(--primary-color);\r\n  padding-left: 1em;\r\n  margin: 2em 0;\r\n  background-color: var(--secondary-background-color);\r\n  border-radius: 0 var(--border-radius-slice) var(--border-radius-slice) 0;\r\n  padding: 0.5em 1em;\r\n}\n",
    "size": 19930
  },
  "Table": {
    "name": "Table",
    "category": "Visual",
    "categoryType": "Visual",
    "js": "class Table extends HTMLElement {\n  static props = {\n    headers: { type: 'array', default: [], required: false },\n    rows: { type: 'array', default: [], required: false }\n  };\n\n  constructor(props) {\n    super();\n    slice.attachTemplate(this);\n\n    this.$head = this.querySelector('.table_head');\n    this.$body = this.querySelector('.table_body');\n\n    slice.controller.setComponentProps(this, props);\n  }\n\n  init() {\n    this.renderTable();\n  }\n\n  set headers(value) {\n    this._headers = Array.isArray(value) ? value : [];\n    this.renderTable();\n  }\n\n  get headers() {\n    return this._headers;\n  }\n\n  set rows(value) {\n    this._rows = Array.isArray(value) ? value : [];\n    this.renderTable();\n  }\n\n  get rows() {\n    return this._rows;\n  }\n\n  renderTable() {\n    if (!this.$head || !this.$body) return;\n\n    this.$head.innerHTML = '';\n    this.$body.innerHTML = '';\n\n    const headers = Array.isArray(this.headers) ? this.headers : [];\n    const rows = Array.isArray(this.rows) ? this.rows : [];\n\n    if (headers.length > 0) {\n      const headRow = document.createElement('tr');\n      headers.forEach((header) => {\n        const th = document.createElement('th');\n        th.textContent = header;\n        headRow.appendChild(th);\n      });\n      this.$head.appendChild(headRow);\n    }\n\n    rows.forEach((row) => {\n      const tr = document.createElement('tr');\n      (Array.isArray(row) ? row : []).forEach((cell, index) => {\n        const td = document.createElement('td');\n        td.innerHTML = cell;\n        if (headers[index]) {\n          td.dataset.label = headers[index];\n        }\n        tr.appendChild(td);\n      });\n      this.$body.appendChild(tr);\n    });\n  }\n}\n\nwindow.Table = Table;\ncustomElements.define('slice-table', Table);\n\nreturn Table;",
    "externalDependencies": {},
    "componentDependencies": [],
    "html": "<div class=\"table_component\">\n  <div class=\"table_wrapper\">\n    <table class=\"table\">\n      <thead class=\"table_head\"></thead>\n      <tbody class=\"table_body\"></tbody>\n    </table>\n  </div>\n</div>\n",
    "css": "/* Table component styles */\n\nslice-table {\n  display: block;\n  width: 100%;\n}\n\nslice-table .table_wrapper {\n  width: 100%;\n  overflow-x: auto;\n  max-width: 100%;\n  display: block;\n  -webkit-overflow-scrolling: touch;\n}\n\nslice-table .table {\n  width: 100%;\n  border-collapse: collapse;\n  font-size: 0.95rem;\n}\n\nslice-table .table th,\nslice-table .table td {\n  padding: 10px 12px;\n  text-align: left;\n  border-bottom: 1px solid var(--primary-color-shade);\n}\n\nslice-table .table th {\n  color: var(--primary-color-contrast);\n  font-weight: 600;\n  background: var(--primary-color);\n}\n\nslice-table .table td code {\n  background: var(--secondary-background-color);\n  padding: 2px 6px;\n  border-radius: 4px;\n}\n\n@media (max-width: 640px) {\n  slice-table .table_wrapper {\n    overflow: visible;\n    display: flex;\n    justify-content: center;\n  }\n\n  slice-table .table,\n  slice-table .table thead,\n  slice-table .table tbody,\n  slice-table .table tr,\n  slice-table .table th,\n  slice-table .table td {\n    display: block;\n    width: 100%;\n  }\n\n  slice-table .table {\n    width: min(92%, 560px);\n    margin: 0 auto;\n  }\n\n  slice-table .table thead {\n    display: none;\n  }\n\n  slice-table .table tr {\n    border: 1px solid var(--primary-color-shade);\n    border-radius: var(--border-radius-slice);\n    padding: 10px 12px;\n    margin-bottom: 12px;\n    background: var(--secondary-background-color);\n    display: grid;\n    grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));\n    gap: 10px 16px;\n  }\n\n  slice-table .table td {\n    border: none;\n    padding: 0;\n    display: grid;\n    grid-template-columns: auto 1fr;\n    align-items: baseline;\n    column-gap: 8px;\n    row-gap: 4px;\n  }\n\n  slice-table .table td::before {\n    content: attr(data-label);\n    font-size: 0.75rem;\n    text-transform: uppercase;\n    letter-spacing: 0.08em;\n    color: var(--primary-color);\n    font-weight: 700;\n    white-space: nowrap;\n  }\n\n  slice-table .table td > * {\n    min-width: 0;\n  }\n\n  slice-table .table td code {\n    display: inline-block;\n  }\n}\n",
    "size": 3976
  },
  "CodeVisualizer": {
    "name": "CodeVisualizer",
    "category": "Visual",
    "categoryType": "Visual",
    "js": "class CodeVisualizer extends HTMLElement {\r\n   constructor(props) {\r\n      super();\r\n      slice.attachTemplate(this);\r\n\r\n      this.$container = this.querySelector('.codevisualizer_container');\r\n      this.$code = this.querySelector('.codevisualizer');\r\n      this.$copyButton = this.querySelector('.copy-button');\r\n\r\n      // Configurar el botón de copiado\r\n      this.$copyButton.addEventListener('click', () => this.copyCodeToClipboard());\r\n\r\n      slice.controller.setComponentProps(this, props);\r\n      this.debuggerProps = ['language', 'value'];\r\n   }\r\n\r\n   set value(value) {\r\n      this._value = value;\r\n   }\r\n\r\n   get value() {\r\n      return this._value;\r\n   }\r\n\r\n   set language(value) {\r\n      this._language = value;\r\n   }\r\n\r\n   get language() {\r\n      return this._language;\r\n   }\r\n\r\n   init() {\r\n      this.visualizeCode();\r\n   }\r\n\r\n   visualizeCode() {\r\n      if (this._value && this._language) {\r\n         const highlightedCode = this.highlightCode(this._value, this._language);\r\n         this.$code.innerHTML = `<pre><code class=\"language-${this._language}\">${highlightedCode}</code></pre>`;\r\n      }\r\n   }\r\n\r\n   copyCodeToClipboard() {\r\n      // Obtenemos el texto sin formato (sin las etiquetas HTML de resaltado)\r\n      const textToCopy = this._value;\r\n      \r\n      // Utilizar el API de clipboard\r\n      navigator.clipboard.writeText(textToCopy)\r\n         .then(() => {\r\n            // Cambiar el texto del botón temporalmente para indicar éxito\r\n            this.$copyButton.textContent = '✓ Copiado!';\r\n            this.$copyButton.classList.add('copied');\r\n            \r\n            // Restaurar el texto original después de 1.5 segundos\r\n            setTimeout(() => {\r\n               this.$copyButton.textContent = 'Copiar';\r\n               this.$copyButton.classList.remove('copied');\r\n            }, 1500);\r\n         })\r\n         .catch(err => {\r\n            console.error('Error al copiar al portapapeles: ', err);\r\n            this.$copyButton.textContent = '❌ Error!';\r\n            \r\n            setTimeout(() => {\r\n               this.$copyButton.textContent = 'Copiar';\r\n            }, 1500);\r\n         });\r\n   }\r\n\r\n   highlightCode(code, language) {\r\n      // Escape HTML to prevent XSS\r\n      const escapedCode = this.escapeHtml(code);\r\n      \r\n      switch (language.toLowerCase()) {\r\n         case 'javascript':\r\n         case 'js':\r\n            return this.highlightJavaScript(escapedCode);\r\n         case 'html':\r\n            return this.highlightHtml(escapedCode);\r\n         case 'css':\r\n            return this.highlightCss(escapedCode);\r\n         default:\r\n            return escapedCode;\r\n      }\r\n   }\r\n\r\n   escapeHtml(text) {\r\n      return text\r\n         .replace(/&/g, '&amp;')\r\n         .replace(/</g, '&lt;')\r\n         .replace(/>/g, '&gt;')\r\n         .replace(/\"/g, '&quot;');\n   }\r\n\r\n   highlightJavaScript(code) {\r\n      // Este método fue rediseñado por completo para evitar problemas de superposición\r\n      let tokenizedCode = code;\r\n      \r\n      // Creamos una estructura para almacenar todos los tokens y luego reemplazarlos de una sola vez\r\n      const tokens = [];\r\n      \r\n      // Función para generar un ID único para cada token\r\n      const generateTokenId = (index) => `__TOKEN_${index}__`;\r\n      \r\n      // Función para extraer tokens y reemplazarlos con marcadores\r\n      const extractTokens = (regex, className) => {\r\n         tokenizedCode = tokenizedCode.replace(regex, (match) => {\r\n            const tokenId = generateTokenId(tokens.length);\r\n            tokens.push({ id: tokenId, content: match, className });\r\n            return tokenId;\r\n         });\r\n      };\r\n      \r\n      // Extraer los tokens en orden específico para evitar interferencias\r\n      \r\n      // 1. Primero los comentarios\r\n      extractTokens(/\\/\\/.*$/gm, 'code-comment');\r\n      extractTokens(/\\/\\*[\\s\\S]*?\\*\\//g, 'code-comment');\r\n      \r\n      // 2. Luego las cadenas de texto\r\n      extractTokens(/(['\"`])(?:\\\\.|[^\\\\])*?\\1/g, 'code-string');\r\n      \r\n      // 3. Luego los números\r\n      extractTokens(/\\b(\\d+(?:\\.\\d+)?)\\b/g, 'code-number');\r\n      \r\n      // 4. Palabras clave\r\n      const keywords = [\r\n         'await', 'async', 'break', 'case', 'catch', 'class', 'const', 'continue',\r\n         'debugger', 'default', 'delete', 'do', 'else', 'export', 'extends', 'false',\r\n         'finally', 'for', 'function', 'if', 'import', 'in', 'instanceof', 'new',\r\n         'null', 'return', 'super', 'switch', 'this', 'throw', 'true', 'try',\r\n         'typeof', 'var', 'void', 'while', 'with', 'yield', 'let'\r\n      ];\r\n      extractTokens(new RegExp(`\\\\b(${keywords.join('|')})\\\\b`, 'g'), 'code-keyword');\r\n      \r\n      // 5. Objetos y métodos integrados\r\n      const builtins = [\r\n         'Array', 'Boolean', 'Date', 'Error', 'Function', 'JSON', 'Math',\r\n         'Number', 'Object', 'Promise', 'RegExp', 'String', 'console', 'document',\r\n         'window', 'slice', 'Map', 'Set', 'Symbol', 'setTimeout', 'setInterval'\r\n      ];\r\n      extractTokens(new RegExp(`\\\\b(${builtins.join('|')})\\\\b`, 'g'), 'code-builtin');\r\n      \r\n      // 6. Métodos y llamadas a funciones (esto debe ir después de extraer las palabras clave)\r\n      extractTokens(/(\\.)([a-zA-Z_$][\\w$]*)\\s*(?=\\()/g, 'code-method');\r\n      \r\n      // Reemplazar los tokens con el HTML resaltado\r\n      tokens.forEach(token => {\r\n         tokenizedCode = tokenizedCode.replace(\r\n            token.id, \r\n            `<span class=\"${token.className}\">${token.content}</span>`\r\n         );\r\n      });\r\n      \r\n      return tokenizedCode;\r\n   }\r\n\r\n   highlightHtml(code) {\r\n      // Utilizamos un enfoque similar al de JavaScript para HTML\r\n      let tokenizedCode = code;\r\n      const tokens = [];\r\n      const generateTokenId = (index) => `__TOKEN_${index}__`;\r\n      \r\n      const extractTokens = (regex, className) => {\r\n         tokenizedCode = tokenizedCode.replace(regex, (match) => {\r\n            const tokenId = generateTokenId(tokens.length);\r\n            tokens.push({ id: tokenId, content: match, className });\r\n            return tokenId;\r\n         });\r\n      };\r\n      \r\n      // Extraer tokens HTML en orden\r\n      \r\n      // 1. Comentarios HTML\r\n      extractTokens(/&lt;!--[\\s\\S]*?--&gt;/g, 'code-comment');\r\n      \r\n      // 2. Etiquetas HTML\r\n      extractTokens(/(&lt;\\/?[a-zA-Z0-9-]+)(\\s|&gt;)/g, (match, tag, end) => {\r\n         const tokenId = generateTokenId(tokens.length);\r\n         tokens.push({ \r\n            id: tokenId, \r\n            content: `<span class=\"code-tag\">${tag}</span>${end}`,\r\n            className: 'no-class' // Ya incluye su propio elemento span\r\n         });\r\n         return tokenId;\r\n      });\r\n      \r\n      // 3. Atributos HTML\r\n      extractTokens(/\\s([a-zA-Z0-9-]+)=(&quot;|')/g, (match, attr, quote) => {\n         const tokenId = generateTokenId(tokens.length);\r\n         tokens.push({ \r\n            id: tokenId, \r\n            content: ` <span class=\"code-attribute\">${attr}</span>=${quote}`,\r\n            className: 'no-class' // Ya incluye su propio elemento span\r\n         });\r\n         return tokenId;\r\n      });\r\n      \r\n      // Reemplazar los tokens con el HTML resaltado\r\n      tokens.forEach(token => {\r\n         tokenizedCode = tokenizedCode.replace(\r\n            token.id, \r\n            token.className === 'no-class' ? token.content : `<span class=\"${token.className}\">${token.content}</span>`\r\n         );\r\n      });\r\n      \r\n      return tokenizedCode;\r\n   }\r\n\r\n   highlightCss(code) {\r\n      // Utilizamos el mismo enfoque para CSS\r\n      let tokenizedCode = code;\r\n      const tokens = [];\r\n      const generateTokenId = (index) => `__TOKEN_${index}__`;\r\n      \r\n      const extractTokens = (regex, className, processor = null) => {\r\n         tokenizedCode = tokenizedCode.replace(regex, (match, ...groups) => {\r\n            const tokenId = generateTokenId(tokens.length);\r\n            const content = processor ? processor(match, ...groups) : match;\r\n            tokens.push({ id: tokenId, content, className });\r\n            return tokenId;\r\n         });\r\n      };\r\n      \r\n      // Comentarios CSS\r\n      extractTokens(/\\/\\*[\\s\\S]*?\\*\\//g, 'code-comment');\r\n      \r\n      // Selectores CSS\r\n      extractTokens(/([^\\{\\}]+)(?=\\{)/g, 'code-selector');\r\n      \r\n      // Propiedad y valor CSS (manipulando la coincidencia para preservar la estructura)\r\n      tokenizedCode = tokenizedCode.replace(/(\\s*)([a-zA-Z-]+)(\\s*):(\\s*)([^;\\{\\}]+)(?=;)/g, (match, space1, prop, space2, space3, value) => {\r\n         const propTokenId = generateTokenId(tokens.length);\r\n         tokens.push({ id: propTokenId, content: prop, className: 'code-property' });\r\n         \r\n         const valueTokenId = generateTokenId(tokens.length);\r\n         tokens.push({ id: valueTokenId, content: value, className: 'code-value' });\r\n         \r\n         return `${space1}<span class=\"code-property\">${prop}</span>${space2}:${space3}<span class=\"code-value\">${value}</span>`;\r\n      });\r\n      \r\n      // Colores CSS\r\n      extractTokens(/#([a-fA-F0-9]{3,6})\\b/g, 'code-color');\r\n      \r\n      // Reemplazar los tokens restantes\r\n      tokens.forEach(token => {\r\n         if (token.className !== 'no-replace') {\r\n            tokenizedCode = tokenizedCode.replace(\r\n               token.id, \r\n               `<span class=\"${token.className}\">${token.content}</span>`\r\n            );\r\n         }\r\n      });\r\n      \r\n      return tokenizedCode;\r\n   }\r\n}\r\n\r\nwindow.CodeVisualizer = CodeVisualizer;\ncustomElements.define('slice-codevisualizer', CodeVisualizer);\r\n\r\n   \n\nreturn CodeVisualizer;",
    "externalDependencies": {},
    "componentDependencies": [],
    "html": "<div class=\"codevisualizer_container\">\r\n  <button class=\"copy-button\" title=\"Copy to clipboard\">Copy</button>\r\n  <pre class=\"codevisualizer\"><code></code></pre>\r\n</div>",
    "css": "slice-codevisualizer {\r\n  display: block;\r\n  width: 100%;\r\n}\r\n\r\n.codevisualizer_container {\r\n  position: relative;\r\n  font-size: smaller;\r\n  max-width: 100%;\r\n  background-color: var(--secondary-background-color);\r\n  border: 1px solid var(--primary-color);\r\n  padding: 15px 10px 10px;\r\n  border-radius: var(--border-radius-slice, 10px);\r\n  overflow-x: auto;\r\n  margin: 15px 0;\r\n}\r\n\r\n.codevisualizer pre {\r\n  margin: 0;\r\n  padding: 0;\r\n  font-family: 'Courier New', Courier, monospace;\r\n  line-height: 1.5;\r\n  white-space: pre;\r\n  tab-size: 2;\r\n}\r\n\r\n.codevisualizer code {\r\n  display: block;\r\n  color: var(--font-primary-color);\r\n  overflow-wrap: normal;\r\n  word-break: normal;\r\n}\r\n\r\n/* Botón de copiar */\r\n.copy-button {\r\n  position: absolute;\r\n  top: 5px;\r\n  right: 10px;\r\n  padding: 4px 8px;\r\n  font-size: 12px;\r\n  background-color: var(--primary-color);\r\n  color: var(--primary-color-contrast);\r\n  border: none;\r\n  border-radius: var(--border-radius-slice, 4px);\r\n  cursor: pointer;\r\n  opacity: 0.7;\r\n  transition: opacity 0.2s ease, background-color 0.2s ease;\r\n  z-index: 1;\r\n}\r\n\r\n.copy-button:hover {\r\n  opacity: 1;\r\n}\r\n\r\n.copy-button.copied {\r\n  background-color: var(--success-color);\r\n  color: var(--success-contrast);\r\n  opacity: 1;\r\n}\r\n\r\n/* Temas para resaltado de sintaxis adaptados a las variables de Slice */\r\n.codevisualizer .code-keyword {\r\n  color: var(--primary-color); /* Palabras clave en color primario */\r\n}\r\n\r\n.codevisualizer .code-string {\r\n  color: var(--success-color); /* Strings en color de éxito */\r\n}\r\n\r\n.codevisualizer .code-number {\r\n  color: var(--warning-color); /* Números en color de advertencia */\r\n}\r\n\r\n.codevisualizer .code-comment {\r\n  color: var(--medium-color); /* Comentarios en color medio */\r\n  font-style: italic;\r\n}\r\n\r\n.codevisualizer .code-function {\r\n  color: var(--secondary-color); /* Funciones en color secundario */\r\n}\r\n\r\n.codevisualizer .code-method {\r\n  color: var(--secondary-color); /* Métodos en color secundario */\r\n}\r\n\r\n.codevisualizer .code-builtin {\r\n  color: var(--secondary-color); /* Objetos integrados en color secundario */\r\n}\r\n\r\n.codevisualizer .code-tag {\r\n  color: var(--primary-color); /* Tags HTML en color primario */\r\n}\r\n\r\n.codevisualizer .code-attribute {\r\n  color: var(--warning-color); /* Atributos HTML en color de advertencia */\r\n}\r\n\r\n.codevisualizer .code-selector {\r\n  color: var(--primary-color); /* Selectores CSS en color primario */\r\n}\r\n\r\n.codevisualizer .code-property {\r\n  color: var(--secondary-color); /* Propiedades CSS en color secundario */\r\n}\r\n\r\n.codevisualizer .code-value {\r\n  color: var(--success-color); /* Valores CSS en color de éxito */\r\n}\r\n\r\n.codevisualizer .code-unit {\r\n  color: var(--warning-color); /* Unidades CSS en color de advertencia */\r\n}\r\n\r\n.codevisualizer .code-color {\r\n  color: var(--font-primary-color); /* Colores CSS en color primario */\r\n}\r\n\r\n/* Media query para diseño responsivo */\r\n@media screen and (max-width: 768px) {\r\n  .codevisualizer_container {\r\n    font-size: 12px;\r\n    padding: 25px 8px 8px;\r\n  }\r\n  \r\n  .copy-button {\r\n    font-size: 10px;\r\n    padding: 3px 6px;\r\n  }\r\n}",
    "size": 12782
  },
  "CopyMarkdownMenu": {
    "name": "CopyMarkdownMenu",
    "category": "AppComponents",
    "categoryType": "Visual",
    "js": "class CopyMarkdownMenu extends HTMLElement {\r\n  static props = {\n    markdownPath: {\n      type: 'string',\n      default: '',\n      required: false\n    },\n    markdownContent: {\n      type: 'string',\n      default: '',\n      required: false\n    },\n    label: {\n      type: 'string',\n      default: '❐',\n      required: false\n    }\n  };\n\r\n  constructor(props) {\r\n    super();\r\n    slice.attachTemplate(this);\r\n\r\n    this.$buttonSlot = this.querySelector('.copy-md-button-slot');\r\n    this.$menu = this.querySelector('.copy-md-menu');\r\n    this.$menuItem = this.querySelector('.copy-md-menu-item');\r\n\r\n    slice.controller.setComponentProps(this, props);\r\n  }\r\n\r\n  async init() {\r\n    await this.renderButton();\r\n    this.setupMenuHandlers();\r\n  }\r\n\r\n  set markdownPath(value) {\n    this._markdownPath = value;\n  }\n\r\n  get markdownPath() {\n    return this._markdownPath;\n  }\n\n  set markdownContent(value) {\n    this._markdownContent = value;\n  }\n\n  get markdownContent() {\n    return this._markdownContent;\n  }\n\r\n  set label(value) {\r\n    this._label = value;\r\n    if (this.$button) {\r\n      this.$button.value = value;\r\n    }\r\n  }\r\n\r\n  get label() {\r\n    return this._label;\r\n  }\r\n\r\n  async renderButton() {\r\n    this.$button = await slice.build('Button', {\r\n      value: this.label || '❐',\r\n      onClickCallback: () => this.toggleMenu()\r\n    });\r\n\r\n    this.$buttonSlot.appendChild(this.$button);\r\n  }\r\n\r\n  setupMenuHandlers() {\r\n    this.$buttonSlot.addEventListener('click', (event) => {\r\n      event.stopPropagation();\r\n    });\r\n\r\n    this.$menuItem.addEventListener('click', async () => {\r\n      await this.copyMarkdown();\r\n      this.closeMenu();\r\n    });\r\n\r\n    document.addEventListener('click', () => {\r\n      this.closeMenu();\r\n    });\r\n  }\r\n\r\n  toggleMenu() {\r\n    this.$menu.classList.toggle('open');\r\n  }\r\n\r\n  closeMenu() {\r\n    this.$menu.classList.remove('open');\r\n  }\r\n\r\n  async copyMarkdown() {\n    if (!this.markdownContent) return;\n    try {\n      await navigator.clipboard.writeText(this.markdownContent);\n      this.showCopySuccess();\n    } catch (error) {\n      console.warn('Copy markdown failed:', error);\n    }\n  }\n\r\n  showCopySuccess() {\r\n    if (!this.$button) return;\r\n    const original = this.$button.value || '❐';\r\n    this.$button.value = '✓';\r\n    setTimeout(() => {\r\n      this.$button.value = original;\r\n    }, 1500);\r\n  }\r\n}\r\n\r\nwindow.CopyMarkdownMenu = CopyMarkdownMenu;\ncustomElements.define('slice-copymarkdownmenu', CopyMarkdownMenu);\r\n\nreturn CopyMarkdownMenu;",
    "externalDependencies": {},
    "componentDependencies": [
      "Button"
    ],
    "html": "<div class=\"copy-md-menu-container\">\n  <div class=\"copy-md-button-slot\"></div>\n  <div class=\"copy-md-menu\">\n    <button type=\"button\" class=\"copy-md-menu-item\">Copy page as markdown</button>\n  </div>\n</div>\n",
    "css": "slice-copymarkdownmenu {\n  display: inline-flex;\n  align-items: center;\n  position: relative;\n}\n\nslice-copymarkdownmenu .copy-md-menu {\n  position: absolute;\n  top: calc(100% + 8px);\n  left: 0;\n  background: var(--primary-background-color);\n  border: 1px solid var(--primary-color-shade);\n  border-radius: var(--border-radius-slice);\n  padding: 8px;\n  box-shadow: 0 8px 20px rgba(0, 0, 0, 0.15);\n  opacity: 0;\n  visibility: hidden;\n  transform: translateY(-6px);\n  transition: all 0.2s ease;\n  z-index: 10;\n}\n\n@media (max-width: 768px) {\n  slice-copymarkdownmenu .copy-md-menu {\n    left: 0;\n  }\n}\n\nslice-copymarkdownmenu .copy-md-menu.open {\n  opacity: 1;\n  visibility: visible;\n  transform: translateY(0);\n}\n\nslice-copymarkdownmenu .copy-md-menu-item {\n  background: none;\n  border: none;\n  color: var(--font-primary-color);\n  font-weight: 600;\n  cursor: pointer;\n  padding: 6px 8px;\n  border-radius: var(--border-radius-slice);\n  width: 100%;\n  text-align: left;\n}\n\nslice-copymarkdownmenu .copy-md-menu-item:hover {\n  background: var(--secondary-background-color);\n}\n\nslice-copymarkdownmenu .copy-md-button-slot .slice_button_container {\n  padding: 0;\n  width: auto;\n  display: inline-flex;\n}\n\nslice-copymarkdownmenu .copy-md-button-slot .slice_button {\n  min-width: auto;\n  width: auto;\n  min-height: 34px;\n  width: 34px;\n  padding: 4px;\n}\n\nslice-copymarkdownmenu .copy-md-button-slot .slice_button_value {\n  font-size: 18px;\n  line-height: 1;\n}\n",
    "size": 4112
  },
  "Button": {
    "name": "Button",
    "category": "Visual",
    "categoryType": "Visual",
    "js": "class Button extends HTMLElement {\r\n\r\n   static props = {\r\n      value: { \r\n         type: 'string', \r\n         default: 'Button', \r\n         required: false \r\n      },\r\n      onClickCallback: { \r\n         type: 'function', \r\n         default: null \r\n      },\r\n      customColor: { \r\n         type: 'object', \r\n         default: null \r\n      },\r\n      icon: { \r\n         type: 'object', \r\n         default: null \r\n      }\r\n   };\r\n\r\n   constructor(props) {\r\n      super();\r\n      slice.attachTemplate(this);\r\n      this.$value = this.querySelector('.slice_button_value');\r\n      this.$button = this.querySelector('.slice_button');\r\n      this.$container = this.querySelector('.slice_button_container');\r\n      \r\n      if (props.onClickCallback) {\r\n         this.onClickCallback = props.onClickCallback;\r\n         this.$container.addEventListener('click', async () => await this.onClickCallback());\r\n      }\r\n\r\n      slice.controller.setComponentProps(this, props);\r\n   }\r\n\r\n   async init() {\r\n      if (this.icon) {\r\n         this.$icon = await slice.build('Icon', {\r\n            name: this.icon.name,           // ✅ CORREGIDO: usar this.icon.name\r\n            iconStyle: this.icon.iconStyle, // ✅ AÑADIDO: pasar también iconStyle\r\n            size: '20px',\r\n            color: 'currentColor',\r\n         });\r\n         this.$button.insertBefore(this.$icon, this.$value);\r\n      }\r\n   }\r\n\r\n   get icon() {\r\n      return this._icon;\r\n   }\r\n\r\n   set icon(value) {\r\n      this._icon = value;\r\n      if (!this.$icon) return;\r\n      this.$icon.name = value.name;\r\n      this.$icon.iconStyle = value.iconStyle;\r\n   }\r\n\r\n   get value() {\r\n      return this._value;\r\n   }\r\n\r\n   set value(value) {\r\n      this._value = value;\r\n      this.$value.textContent = value;\r\n   }\r\n\r\n   get customColor() {\r\n      return this._customColor;\r\n   }\r\n\r\n   set customColor(value) {\r\n      this._customColor = value;\r\n      if (!value) return;\r\n\r\n      // Mantener la misma API: { button: 'color', label: 'color' }\r\n      if (value.button) {\r\n         this.$button.style.backgroundColor = value.button;\r\n         this.$button.style.borderColor = value.button;\r\n      }\r\n      if (value.label) {\r\n         this.$button.style.color = value.label;\r\n         this.$value.style.color = value.label;\r\n         // También aplicar al icono si existe\r\n         if (this.$icon) {\r\n            this.$icon.style.color = value.label;\r\n         }\r\n      }\r\n   }\r\n}\r\n\r\nwindow.Button = Button;\ncustomElements.define('slice-button', Button);\nreturn Button;",
    "externalDependencies": {},
    "componentDependencies": [
      "Icon"
    ],
    "html": "<div class=\"slice_button_container\">\r\n  <button class=\"slice_button\">\r\n    <label class=\"slice_button_value\"></label>\r\n  </button>\r\n</div>\r\n",
    "css": ".slice_button_container {\r\n  padding: 10px;\r\n}\r\n.slice_button_value {\r\n  user-select: none;\r\n  cursor: pointer;\r\n}\r\n.slice_button {\r\n  display: flex;\r\n  align-items: center;\r\n  justify-content: center;\r\n  cursor: pointer;\r\n  overflow: hidden;\r\n  position: relative;\r\n  max-width: fit-content;\r\n  background-color: var(--primary-color);\r\n  color: var(--primary-color-contrast);\r\n  border-radius: var(--border-radius-slice);\r\n  border: var(--slice-border) solid var(--primary-color);\r\n  font-weight: 800;\r\n  min-width: 100%;\r\n  padding: 10px;\r\n  -webkit-transition-duration: 0.4s; /* Safari */\r\n  transition-duration: 0.4s;\r\n}\r\n.slice_button:after {\r\n  content: \"\";\r\n  width: 100%;\r\n  height: 100%;\r\n  border-radius: 100%;\r\n  background: #ffffff50;\r\n  position: absolute;\r\n  display: block;\r\n  opacity: 0;\r\n  scale: 10;\r\n  transition: all 1s;\r\n}\r\n.slice_button:active {\r\n  transform: translateY(5px);\r\n}\r\n.slice_button:active:after {\r\n  scale: 0;\r\n  padding: 0;\r\n  margin: 0;\r\n  opacity: 1;\r\n  transition: 0s;\r\n}\r\n",
    "size": 3647
  },
  "Icon": {
    "name": "Icon",
    "category": "Visual",
    "categoryType": "Visual",
    "js": "class Icon extends HTMLElement {\r\n\r\n   static props = {\r\n      name: { \r\n         type: 'string', \r\n         default: 'youtube', \r\n         required: false \r\n      },\r\n      size: { \r\n         type: 'string', \r\n         default: 'small' \r\n      },\r\n      color: { \r\n         type: 'string', \r\n         default: 'black' \r\n      },\r\n      iconStyle: { \r\n         type: 'string', \r\n         default: 'filled' \r\n      }\r\n   };\r\n\r\n   constructor(props) {\r\n      super();\r\n\r\n      slice.attachTemplate(this);\r\n      this.$icon = this.querySelector('i');\r\n\r\n      slice.controller.setComponentProps(this, props);\r\n   }\r\n\r\n   get random() {\r\n      return this.$icon.classList;\r\n   }\r\n\r\n   set random(value) {}\r\n\r\n   init() {\r\n      // Static props ensure all properties have default values\r\n      // No need for manual default checking\r\n   }\r\n\r\n   update() {\r\n      // Re-apply all properties to ensure proper styling after router navigation\r\n      // This method is called on each re-render by MultiRoute\r\n      if (this.$icon) {\r\n         if (this._name) this.name = this._name;\r\n         if (this._iconStyle) this.iconStyle = this._iconStyle;\r\n         if (this._size) this.size = this._size;\r\n         if (this._color) this.color = this._color;\r\n      }\r\n   }\r\n\r\n   get name() {\r\n      return this._name;\r\n   }\r\n\r\n   set name(value) {\r\n      this._name = value;\r\n      if (this.$icon) {\r\n         this.$icon.className = '';\r\n         this.$icon.classList.add(`slc-${styleTypes[this._iconStyle]}${value}`);\r\n      }\r\n   }\r\n\r\n   get iconStyle() {\r\n      return this._iconStyle;\r\n   }\r\n\r\n   set iconStyle(value) {\r\n      if (value !== 'filled' && value !== 'outlined') value = 'filled';\r\n      this._iconStyle = value;\r\n      this.name = this._name;\r\n   }\r\n\r\n   get size() {\r\n      return this._size;\r\n   }\r\n\r\n   set size(value) {\r\n      switch (value) {\r\n         case 'small':\r\n            this._size = '16px';\r\n            break;\r\n         case 'medium':\r\n            this._size = '20px';\r\n            break;\r\n         case 'large':\r\n            this._size = '24px';\r\n            break;\r\n         default:\r\n            this._size = value;\r\n      }\r\n\r\n      if (this.$icon) {\r\n         this.$icon.style.fontSize = this._size;\r\n      }\r\n   }\r\n\r\n   get color() {\r\n      return this._color;\r\n   }\r\n\r\n   set color(value) {\r\n      this._color = value;\r\n      if (this.$icon) {\r\n         this.$icon.style.color = value;\r\n      }\r\n   }\r\n}\r\n\r\nconst styleTypes = { outlined: 'out', filled: 'fil' };\r\nwindow.Icon = Icon;\ncustomElements.define('slice-icon', Icon);\r\n\nreturn Icon;",
    "externalDependencies": {},
    "componentDependencies": [],
    "html": "<i class=\"icon\"></i>",
    "css": "@font-face {\r\n  font-family: \"slc\";\r\n  src: url('/Components/Visual/Icon/slc.eot?t=1714090352079'); /* IE9 */\r\n  src: url('/Components/Visual/Icon/slc.eot?t=1714090352079#iefix') format('embedded-opentype'),\r\n       url(\"/Components/Visual/Icon/slc.woff2?t=1714090352079\") format(\"woff2\"),\r\n       url(\"/Components/Visual/Icon/slc.woff?t=1714090352079\") format(\"woff\"),\r\n       url('/Components/Visual/Icon/slc.ttf?t=1714090352079') format('truetype'),\r\n       url('/Components/Visual/Icon/slc.svg?t=1714090352079#slc') format('svg'); /* iOS 4.1- */\r\n}\r\n\r\n[class^=\"slc-\"], [class*=\" slc-\"] {\r\n  font-family: 'slc' !important;\r\n  font-style:normal;\r\n  -webkit-font-smoothing: antialiased;\r\n  -moz-osx-font-smoothing: grayscale;\r\n}\r\n\r\n\r\n.slc-filaddress-book:before { content: \"\\ea01\"; }\r\n.slc-filadjustments-horizontal:before { content: \"\\ea02\"; }\r\n.slc-filadjustments-vertical:before { content: \"\\ea03\"; }\r\n.slc-filannotation:before { content: \"\\ea04\"; }\r\n.slc-filapple:before { content: \"\\ea05\"; }\r\n.slc-filarchive-arrow-down:before { content: \"\\ea06\"; }\r\n.slc-filarchive:before { content: \"\\ea07\"; }\r\n.slc-filarrow-right-alt:before { content: \"\\ea08\"; }\r\n.slc-filarrow-up-right-from-square:before { content: \"\\ea09\"; }\r\n.slc-filbackward-step:before { content: \"\\ea0a\"; }\r\n.slc-filbadge-check:before { content: \"\\ea0b\"; }\r\n.slc-filbell-active-alt:before { content: \"\\ea0c\"; }\r\n.slc-filbell-active:before { content: \"\\ea0d\"; }\r\n.slc-filbell-ring:before { content: \"\\ea0e\"; }\r\n.slc-filbell:before { content: \"\\ea0f\"; }\r\n.slc-filblender-phone:before { content: \"\\ea10\"; }\r\n.slc-filbook-open:before { content: \"\\ea11\"; }\r\n.slc-filbook:before { content: \"\\ea12\"; }\r\n.slc-filbookmark:before { content: \"\\ea13\"; }\r\n.slc-filbrain:before { content: \"\\ea14\"; }\r\n.slc-filbriefcase:before { content: \"\\ea15\"; }\r\n.slc-filbug:before { content: \"\\ea16\"; }\r\n.slc-filbuilding:before { content: \"\\ea17\"; }\r\n.slc-filbullhorn:before { content: \"\\ea18\"; }\r\n.slc-filcalendar-edit:before { content: \"\\ea19\"; }\r\n.slc-filcalendar-month:before { content: \"\\ea1a\"; }\r\n.slc-filcalendar-plus:before { content: \"\\ea1b\"; }\r\n.slc-filcalendar-week:before { content: \"\\ea1c\"; }\r\n.slc-filcamera-photo:before { content: \"\\ea1d\"; }\r\n.slc-filcaption:before { content: \"\\ea1e\"; }\r\n.slc-filcaret-down:before { content: \"\\ea1f\"; }\r\n.slc-filcaret-left:before { content: \"\\ea20\"; }\r\n.slc-filcaret-right:before { content: \"\\ea21\"; }\r\n.slc-filcaret-sort:before { content: \"\\ea22\"; }\r\n.slc-filcaret-up:before { content: \"\\ea23\"; }\r\n.slc-filcart-plus-alt:before { content: \"\\ea24\"; }\r\n.slc-filcart-plus:before { content: \"\\ea25\"; }\r\n.slc-filcart:before { content: \"\\ea26\"; }\r\n.slc-filcash:before { content: \"\\ea27\"; }\r\n.slc-filchart-mixed-dollar:before { content: \"\\ea28\"; }\r\n.slc-filchart-pie:before { content: \"\\ea29\"; }\r\n.slc-filcheck-circle:before { content: \"\\ea2a\"; }\r\n.slc-filcheck-plus-circle:before { content: \"\\ea2b\"; }\r\n.slc-filcircle-pause:before { content: \"\\ea2c\"; }\r\n.slc-filcircle-plus:before { content: \"\\ea2d\"; }\r\n.slc-filclapperboard-play:before { content: \"\\ea2e\"; }\r\n.slc-filclipboard-check:before { content: \"\\ea2f\"; }\r\n.slc-filclipboard-list:before { content: \"\\ea30\"; }\r\n.slc-filclipboard:before { content: \"\\ea31\"; }\r\n.slc-filclock:before { content: \"\\ea32\"; }\r\n.slc-filclose-circle:before { content: \"\\ea33\"; }\r\n.slc-filcloud-arrow-up:before { content: \"\\ea34\"; }\r\n.slc-filcode-branch:before { content: \"\\ea35\"; }\r\n.slc-filcode-fork:before { content: \"\\ea36\"; }\r\n.slc-filcode-merge:before { content: \"\\ea37\"; }\r\n.slc-filcode-pull-request:before { content: \"\\ea38\"; }\r\n.slc-filcog:before { content: \"\\ea39\"; }\r\n.slc-filcolumn:before { content: \"\\ea3a\"; }\r\n.slc-filcomputer-speaker:before { content: \"\\ea3b\"; }\r\n.slc-filcredit-card:before { content: \"\\ea3c\"; }\r\n.slc-filcss:before { content: \"\\ea3d\"; }\r\n.slc-fildatabase:before { content: \"\\ea3e\"; }\r\n.slc-fildesktop-pc:before { content: \"\\ea3f\"; }\r\n.slc-fildiscord:before { content: \"\\ea40\"; }\r\n.slc-fildownload:before { content: \"\\ea41\"; }\r\n.slc-fildraw-square:before { content: \"\\ea42\"; }\r\n.slc-fildribbble:before { content: \"\\ea43\"; }\r\n.slc-fildropbox:before { content: \"\\ea44\"; }\r\n.slc-filedit:before { content: \"\\ea45\"; }\r\n.slc-filenvelope-open:before { content: \"\\ea46\"; }\r\n.slc-filenvelope:before { content: \"\\ea47\"; }\r\n.slc-filexclamation-circle:before { content: \"\\ea48\"; }\r\n.slc-fileye-slash:before { content: \"\\ea49\"; }\r\n.slc-fileye:before { content: \"\\ea4a\"; }\r\n.slc-filface-explode:before { content: \"\\ea4b\"; }\r\n.slc-filface-grin-stars:before { content: \"\\ea4c\"; }\r\n.slc-filface-grin:before { content: \"\\ea4d\"; }\r\n.slc-filface-laugh:before { content: \"\\ea4e\"; }\r\n.slc-filfacebook:before { content: \"\\ea4f\"; }\r\n.slc-filfile-chart-bar:before { content: \"\\ea50\"; }\r\n.slc-filfile-check:before { content: \"\\ea51\"; }\r\n.slc-filfile-circle-plus:before { content: \"\\ea52\"; }\r\n.slc-filfile-clone:before { content: \"\\ea53\"; }\r\n.slc-filfile-code:before { content: \"\\ea54\"; }\r\n.slc-filfile-copy-alt:before { content: \"\\ea55\"; }\r\n.slc-filfile-copy:before { content: \"\\ea56\"; }\r\n.slc-filfile-csv:before { content: \"\\ea57\"; }\r\n.slc-filfile-export:before { content: \"\\ea58\"; }\r\n.slc-filfile-image:before { content: \"\\ea59\"; }\r\n.slc-filfile-import:before { content: \"\\ea5a\"; }\r\n.slc-filfile-invoice:before { content: \"\\ea5b\"; }\r\n.slc-filfile-lines:before { content: \"\\ea5c\"; }\r\n.slc-filfile-music:before { content: \"\\ea5d\"; }\r\n.slc-filfile-paste:before { content: \"\\ea5e\"; }\r\n.slc-filfile-pdf:before { content: \"\\ea5f\"; }\r\n.slc-filfile-pen:before { content: \"\\ea60\"; }\r\n.slc-filfile-ppt:before { content: \"\\ea61\"; }\r\n.slc-filfile-search:before { content: \"\\ea62\"; }\r\n.slc-filfile-shield:before { content: \"\\ea63\"; }\r\n.slc-filfile-video:before { content: \"\\ea64\"; }\r\n.slc-filfile-word:before { content: \"\\ea65\"; }\r\n.slc-filfile-zip:before { content: \"\\ea66\"; }\r\n.slc-filfile:before { content: \"\\ea67\"; }\r\n.slc-filfilter:before { content: \"\\ea68\"; }\r\n.slc-filfire:before { content: \"\\ea69\"; }\r\n.slc-filflag:before { content: \"\\ea6a\"; }\r\n.slc-filflowbite:before { content: \"\\ea6b\"; }\r\n.slc-filfolder-arrow-right:before { content: \"\\ea6c\"; }\r\n.slc-filfolder-duplicate:before { content: \"\\ea6d\"; }\r\n.slc-filfolder-open:before { content: \"\\ea6e\"; }\r\n.slc-filfolder-plus:before { content: \"\\ea6f\"; }\r\n.slc-filfolder:before { content: \"\\ea70\"; }\r\n.slc-filforward-step:before { content: \"\\ea71\"; }\r\n.slc-filforward:before { content: \"\\ea72\"; }\r\n.slc-filgift-box:before { content: \"\\ea73\"; }\r\n.slc-filgithub:before { content: \"\\ea74\"; }\r\n.slc-filglobe:before { content: \"\\ea75\"; }\r\n.slc-filgoogle:before { content: \"\\ea76\"; }\r\n.slc-filgrid-plus:before { content: \"\\ea77\"; }\r\n.slc-filgrid:before { content: \"\\ea78\"; }\r\n.slc-filheadphones:before { content: \"\\ea79\"; }\r\n.slc-filheart:before { content: \"\\ea7a\"; }\r\n.slc-filhome:before { content: \"\\ea7b\"; }\r\n.slc-filhourglass:before { content: \"\\ea7c\"; }\r\n.slc-filhtml:before { content: \"\\ea7d\"; }\r\n.slc-filimage:before { content: \"\\ea7e\"; }\r\n.slc-filinbox-full:before { content: \"\\ea7f\"; }\r\n.slc-filinbox:before { content: \"\\ea80\"; }\r\n.slc-filindent:before { content: \"\\ea81\"; }\r\n.slc-filinfo-circle:before { content: \"\\ea82\"; }\r\n.slc-filjavascript:before { content: \"\\ea83\"; }\r\n.slc-filkeyboard:before { content: \"\\ea84\"; }\r\n.slc-fillabel:before { content: \"\\ea85\"; }\r\n.slc-fillandmark:before { content: \"\\ea86\"; }\r\n.slc-fillayers:before { content: \"\\ea87\"; }\r\n.slc-fillife-saver:before { content: \"\\ea88\"; }\r\n.slc-fillightbulb:before { content: \"\\ea89\"; }\r\n.slc-fillinkedin:before { content: \"\\ea8a\"; }\r\n.slc-fillist-music:before { content: \"\\ea8b\"; }\r\n.slc-fillock-open:before { content: \"\\ea8c\"; }\r\n.slc-fillock-time:before { content: \"\\ea8d\"; }\r\n.slc-fillock:before { content: \"\\ea8e\"; }\r\n.slc-filmail-box:before { content: \"\\ea8f\"; }\r\n.slc-filmap-pin-alt:before { content: \"\\ea90\"; }\r\n.slc-filmap-pin:before { content: \"\\ea91\"; }\r\n.slc-filmessage-caption:before { content: \"\\ea92\"; }\r\n.slc-filmessage-dots:before { content: \"\\ea93\"; }\r\n.slc-filmessages:before { content: \"\\ea94\"; }\r\n.slc-filmicrophone:before { content: \"\\ea95\"; }\r\n.slc-filmobile-phone:before { content: \"\\ea96\"; }\r\n.slc-filmoon:before { content: \"\\ea97\"; }\r\n.slc-filnewspaper:before { content: \"\\ea98\"; }\r\n.slc-filnpm:before { content: \"\\ea99\"; }\r\n.slc-filoutdent:before { content: \"\\ea9a\"; }\r\n.slc-filpalette:before { content: \"\\ea9b\"; }\r\n.slc-filpaper-plane:before { content: \"\\ea9c\"; }\r\n.slc-filparagraph:before { content: \"\\ea9d\"; }\r\n.slc-filpause:before { content: \"\\ea9e\"; }\r\n.slc-filpen-nib:before { content: \"\\ea9f\"; }\r\n.slc-filpen:before { content: \"\\eaa0\"; }\r\n.slc-filphone:before { content: \"\\eaa1\"; }\r\n.slc-filplay:before { content: \"\\eaa2\"; }\r\n.slc-filprinter:before { content: \"\\eaa3\"; }\r\n.slc-filprofile-card:before { content: \"\\eaa4\"; }\r\n.slc-filquestion-circle:before { content: \"\\eaa5\"; }\r\n.slc-filquote:before { content: \"\\eaa6\"; }\r\n.slc-filreact:before { content: \"\\eaa7\"; }\r\n.slc-filreceipt:before { content: \"\\eaa8\"; }\r\n.slc-filrectangle-list:before { content: \"\\eaa9\"; }\r\n.slc-filreply-all:before { content: \"\\eaaa\"; }\r\n.slc-filreply:before { content: \"\\eaab\"; }\r\n.slc-filrocket:before { content: \"\\eaac\"; }\r\n.slc-filsale-percent:before { content: \"\\eaad\"; }\r\n.slc-filscale-balanced:before { content: \"\\eaae\"; }\r\n.slc-filsearch:before { content: \"\\eaaf\"; }\r\n.slc-filshare-all:before { content: \"\\eab0\"; }\r\n.slc-filshare-nodes:before { content: \"\\eab1\"; }\r\n.slc-filshield-check:before { content: \"\\eab2\"; }\r\n.slc-filshield:before { content: \"\\eab3\"; }\r\n.slc-filshopping-bag:before { content: \"\\eab4\"; }\r\n.slc-filsingleSlice:before { content: \"\\eab5\"; }\r\n.slc-filsliceJs:before { content: \"\\eab6\"; }\r\n.slc-filsliceLogo:before { content: \"\\eab7\"; }\r\n.slc-filslicePizza:before { content: \"\\eab8\"; }\r\n.slc-filstackoverflow:before { content: \"\\eab9\"; }\r\n.slc-filstar-half-stroke:before { content: \"\\eaba\"; }\r\n.slc-filstar-half:before { content: \"\\eabb\"; }\r\n.slc-filstar:before { content: \"\\eabc\"; }\r\n.slc-filstore:before { content: \"\\eabd\"; }\r\n.slc-filsun:before { content: \"\\eabe\"; }\r\n.slc-filswatchbook:before { content: \"\\eabf\"; }\r\n.slc-filtable-column:before { content: \"\\eac0\"; }\r\n.slc-filtable-row:before { content: \"\\eac1\"; }\r\n.slc-filtablet:before { content: \"\\eac2\"; }\r\n.slc-filtag:before { content: \"\\eac3\"; }\r\n.slc-filtailwind:before { content: \"\\eac4\"; }\r\n.slc-filterminal:before { content: \"\\eac5\"; }\r\n.slc-filthumbs-down:before { content: \"\\eac6\"; }\r\n.slc-filthumbs-up:before { content: \"\\eac7\"; }\r\n.slc-filticket:before { content: \"\\eac8\"; }\r\n.slc-filtrash-bin:before { content: \"\\eac9\"; }\r\n.slc-filtruck:before { content: \"\\eaca\"; }\r\n.slc-filtwitter:before { content: \"\\eacb\"; }\r\n.slc-filupload:before { content: \"\\eacc\"; }\r\n.slc-filuser-add:before { content: \"\\eacd\"; }\r\n.slc-filuser-circle:before { content: \"\\eace\"; }\r\n.slc-filuser-edit:before { content: \"\\eacf\"; }\r\n.slc-filuser-headset:before { content: \"\\ead0\"; }\r\n.slc-filuser-remove:before { content: \"\\ead1\"; }\r\n.slc-filuser-settings:before { content: \"\\ead2\"; }\r\n.slc-filuser:before { content: \"\\ead3\"; }\r\n.slc-filusers-group:before { content: \"\\ead4\"; }\r\n.slc-filusers:before { content: \"\\ead5\"; }\r\n.slc-filvideo-camera:before { content: \"\\ead6\"; }\r\n.slc-filvolume-down:before { content: \"\\ead7\"; }\r\n.slc-filvolume-up:before { content: \"\\ead8\"; }\r\n.slc-filvue:before { content: \"\\ead9\"; }\r\n.slc-filwallet:before { content: \"\\eada\"; }\r\n.slc-filwand-magic-sparkles:before { content: \"\\eadb\"; }\r\n.slc-filwindow-restore:before { content: \"\\eadc\"; }\r\n.slc-filwindow:before { content: \"\\eadd\"; }\r\n.slc-filX:before { content: \"\\eade\"; }\r\n.slc-filyoutube:before { content: \"\\eadf\"; }\r\n.slc-filzoom-in:before { content: \"\\eae0\"; }\r\n.slc-filzoom-out:before { content: \"\\eae1\"; }\r\n.slc-outaddress-book:before { content: \"\\eae2\"; }\r\n.slc-outadjustments-horizontal:before { content: \"\\eae3\"; }\r\n.slc-outadjustments-vertical:before { content: \"\\eae4\"; }\r\n.slc-outalign-center:before { content: \"\\eae5\"; }\r\n.slc-outangle-down:before { content: \"\\eae6\"; }\r\n.slc-outangle-left:before { content: \"\\eae7\"; }\r\n.slc-outangle-right:before { content: \"\\eae8\"; }\r\n.slc-outangle-up:before { content: \"\\eae9\"; }\r\n.slc-outannotation:before { content: \"\\eaea\"; }\r\n.slc-outarchive-arrow-down:before { content: \"\\eaeb\"; }\r\n.slc-outarchive:before { content: \"\\eaec\"; }\r\n.slc-outarrow-down-to-bracket:before { content: \"\\eaed\"; }\r\n.slc-outarrow-down:before { content: \"\\eaee\"; }\r\n.slc-outarrow-left-to-bracket:before { content: \"\\eaef\"; }\r\n.slc-outarrow-left:before { content: \"\\eaf0\"; }\r\n.slc-outarrow-right-alt:before { content: \"\\eaf1\"; }\r\n.slc-outarrow-right-to-bracket:before { content: \"\\eaf2\"; }\r\n.slc-outarrow-right:before { content: \"\\eaf3\"; }\r\n.slc-outarrow-sort-letters:before { content: \"\\eaf4\"; }\r\n.slc-outarrow-up-down:before { content: \"\\eaf5\"; }\r\n.slc-outarrow-up-from-bracket:before { content: \"\\eaf6\"; }\r\n.slc-outarrow-up-right-down-left:before { content: \"\\eaf7\"; }\r\n.slc-outarrow-up-right-from-square:before { content: \"\\eaf8\"; }\r\n.slc-outarrow-up:before { content: \"\\eaf9\"; }\r\n.slc-outarrows-repeat-count:before { content: \"\\eafa\"; }\r\n.slc-outarrows-repeat:before { content: \"\\eafb\"; }\r\n.slc-outatom:before { content: \"\\eafc\"; }\r\n.slc-outbackward-step:before { content: \"\\eafd\"; }\r\n.slc-outbadge-check:before { content: \"\\eafe\"; }\r\n.slc-outbars-from-left:before { content: \"\\eaff\"; }\r\n.slc-outbars:before { content: \"\\eb00\"; }\r\n.slc-outbell-active-alt:before { content: \"\\eb01\"; }\r\n.slc-outbell-active:before { content: \"\\eb02\"; }\r\n.slc-outbell-ring:before { content: \"\\eb03\"; }\r\n.slc-outbell:before { content: \"\\eb04\"; }\r\n.slc-outblender-phone:before { content: \"\\eb05\"; }\r\n.slc-outbook-open:before { content: \"\\eb06\"; }\r\n.slc-outbook:before { content: \"\\eb07\"; }\r\n.slc-outbookmark:before { content: \"\\eb08\"; }\r\n.slc-outbrain:before { content: \"\\eb09\"; }\r\n.slc-outbriefcase:before { content: \"\\eb0a\"; }\r\n.slc-outbug:before { content: \"\\eb0b\"; }\r\n.slc-outbuilding:before { content: \"\\eb0c\"; }\r\n.slc-outbullhorn:before { content: \"\\eb0d\"; }\r\n.slc-outcalendar-edit:before { content: \"\\eb0e\"; }\r\n.slc-outcalendar-month:before { content: \"\\eb0f\"; }\r\n.slc-outcalendar-plus:before { content: \"\\eb10\"; }\r\n.slc-outcalendar-week:before { content: \"\\eb11\"; }\r\n.slc-outcamera-photo:before { content: \"\\eb12\"; }\r\n.slc-outcaption:before { content: \"\\eb13\"; }\r\n.slc-outcaret-down:before { content: \"\\eb14\"; }\r\n.slc-outcaret-left:before { content: \"\\eb15\"; }\r\n.slc-outcaret-right:before { content: \"\\eb16\"; }\r\n.slc-outcaret-sort:before { content: \"\\eb17\"; }\r\n.slc-outcaret-up:before { content: \"\\eb18\"; }\r\n.slc-outcart-plus-alt:before { content: \"\\eb19\"; }\r\n.slc-outcart-plus:before { content: \"\\eb1a\"; }\r\n.slc-outcart:before { content: \"\\eb1b\"; }\r\n.slc-outcash:before { content: \"\\eb1c\"; }\r\n.slc-outchart-line-down:before { content: \"\\eb1d\"; }\r\n.slc-outchart-line-up:before { content: \"\\eb1e\"; }\r\n.slc-outchart-mixed-dollar:before { content: \"\\eb1f\"; }\r\n.slc-outchart-mixed:before { content: \"\\eb20\"; }\r\n.slc-outchart-pie:before { content: \"\\eb21\"; }\r\n.slc-outchart:before { content: \"\\eb22\"; }\r\n.slc-outcheck-circle:before { content: \"\\eb23\"; }\r\n.slc-outcheck-plus-circle:before { content: \"\\eb24\"; }\r\n.slc-outcheck:before { content: \"\\eb25\"; }\r\n.slc-outchevron-double-down:before { content: \"\\eb26\"; }\r\n.slc-outchevron-double-left:before { content: \"\\eb27\"; }\r\n.slc-outchevron-double-right:before { content: \"\\eb28\"; }\r\n.slc-outchevron-double-up:before { content: \"\\eb29\"; }\r\n.slc-outchevron-down:before { content: \"\\eb2a\"; }\r\n.slc-outchevron-left:before { content: \"\\eb2b\"; }\r\n.slc-outchevron-right:before { content: \"\\eb2c\"; }\r\n.slc-outchevron-sort:before { content: \"\\eb2d\"; }\r\n.slc-outchevron-up:before { content: \"\\eb2e\"; }\r\n.slc-outcircle-pause:before { content: \"\\eb2f\"; }\r\n.slc-outcircle-plus:before { content: \"\\eb30\"; }\r\n.slc-outclapperboard-play:before { content: \"\\eb31\"; }\r\n.slc-outclipboard-check:before { content: \"\\eb32\"; }\r\n.slc-outclipboard-list:before { content: \"\\eb33\"; }\r\n.slc-outclipboard:before { content: \"\\eb34\"; }\r\n.slc-outclock:before { content: \"\\eb35\"; }\r\n.slc-outclose-circle:before { content: \"\\eb36\"; }\r\n.slc-outclose:before { content: \"\\eb37\"; }\r\n.slc-outcloud-arrow-up:before { content: \"\\eb38\"; }\r\n.slc-outcode-branch:before { content: \"\\eb39\"; }\r\n.slc-outcode-fork:before { content: \"\\eb3a\"; }\r\n.slc-outcode-merge:before { content: \"\\eb3b\"; }\r\n.slc-outcode-pull-request:before { content: \"\\eb3c\"; }\r\n.slc-outcode:before { content: \"\\eb3d\"; }\r\n.slc-outcog:before { content: \"\\eb3e\"; }\r\n.slc-outcolumn:before { content: \"\\eb3f\"; }\r\n.slc-outcommand:before { content: \"\\eb40\"; }\r\n.slc-outcompress:before { content: \"\\eb41\"; }\r\n.slc-outcomputer-speaker:before { content: \"\\eb42\"; }\r\n.slc-outcredit-card:before { content: \"\\eb43\"; }\r\n.slc-outdatabase:before { content: \"\\eb44\"; }\r\n.slc-outdesktop-pc:before { content: \"\\eb45\"; }\r\n.slc-outdna:before { content: \"\\eb46\"; }\r\n.slc-outdollar:before { content: \"\\eb47\"; }\r\n.slc-outdots-horizontal:before { content: \"\\eb48\"; }\r\n.slc-outdots-vertical:before { content: \"\\eb49\"; }\r\n.slc-outdownload:before { content: \"\\eb4a\"; }\r\n.slc-outdraw-square:before { content: \"\\eb4b\"; }\r\n.slc-outedit:before { content: \"\\eb4c\"; }\r\n.slc-outenvelope-open:before { content: \"\\eb4d\"; }\r\n.slc-outenvelope:before { content: \"\\eb4e\"; }\r\n.slc-outeuro:before { content: \"\\eb4f\"; }\r\n.slc-outexclamation-circle:before { content: \"\\eb50\"; }\r\n.slc-outexpand:before { content: \"\\eb51\"; }\r\n.slc-outeye-slash:before { content: \"\\eb52\"; }\r\n.slc-outeye:before { content: \"\\eb53\"; }\r\n.slc-outface-explode:before { content: \"\\eb54\"; }\r\n.slc-outface-grin-stars:before { content: \"\\eb55\"; }\r\n.slc-outface-grin:before { content: \"\\eb56\"; }\r\n.slc-outface-laugh:before { content: \"\\eb57\"; }\r\n.slc-outfile-chart-bar:before { content: \"\\eb58\"; }\r\n.slc-outfile-check:before { content: \"\\eb59\"; }\r\n.slc-outfile-circle-plus:before { content: \"\\eb5a\"; }\r\n.slc-outfile-clone:before { content: \"\\eb5b\"; }\r\n.slc-outfile-code:before { content: \"\\eb5c\"; }\r\n.slc-outfile-copy-alt:before { content: \"\\eb5d\"; }\r\n.slc-outfile-copy:before { content: \"\\eb5e\"; }\r\n.slc-outfile-csv:before { content: \"\\eb5f\"; }\r\n.slc-outfile-export:before { content: \"\\eb60\"; }\r\n.slc-outfile-image:before { content: \"\\eb61\"; }\r\n.slc-outfile-import:before { content: \"\\eb62\"; }\r\n.slc-outfile-invoice:before { content: \"\\eb63\"; }\r\n.slc-outfile-lines:before { content: \"\\eb64\"; }\r\n.slc-outfile-music:before { content: \"\\eb65\"; }\r\n.slc-outfile-paste:before { content: \"\\eb66\"; }\r\n.slc-outfile-pdf:before { content: \"\\eb67\"; }\r\n.slc-outfile-pen:before { content: \"\\eb68\"; }\r\n.slc-outfile-ppt:before { content: \"\\eb69\"; }\r\n.slc-outfile-search:before { content: \"\\eb6a\"; }\r\n.slc-outfile-shield:before { content: \"\\eb6b\"; }\r\n.slc-outfile-video:before { content: \"\\eb6c\"; }\r\n.slc-outfile-word:before { content: \"\\eb6d\"; }\r\n.slc-outfile-zip:before { content: \"\\eb6e\"; }\r\n.slc-outfile:before { content: \"\\eb6f\"; }\r\n.slc-outfilter:before { content: \"\\eb70\"; }\r\n.slc-outfingerprint:before { content: \"\\eb71\"; }\r\n.slc-outfire:before { content: \"\\eb72\"; }\r\n.slc-outflag:before { content: \"\\eb73\"; }\r\n.slc-outfolder-arrow-right:before { content: \"\\eb74\"; }\r\n.slc-outfolder-duplicate:before { content: \"\\eb75\"; }\r\n.slc-outfolder-open:before { content: \"\\eb76\"; }\r\n.slc-outfolder-plus:before { content: \"\\eb77\"; }\r\n.slc-outfolder:before { content: \"\\eb78\"; }\r\n.slc-outforward-step:before { content: \"\\eb79\"; }\r\n.slc-outforward:before { content: \"\\eb7a\"; }\r\n.slc-outgift-box:before { content: \"\\eb7b\"; }\r\n.slc-outglobe:before { content: \"\\eb7c\"; }\r\n.slc-outgrid-plus:before { content: \"\\eb7d\"; }\r\n.slc-outgrid:before { content: \"\\eb7e\"; }\r\n.slc-outheadphones:before { content: \"\\eb7f\"; }\r\n.slc-outheart:before { content: \"\\eb80\"; }\r\n.slc-outhome:before { content: \"\\eb81\"; }\r\n.slc-outhourglass:before { content: \"\\eb82\"; }\r\n.slc-outimage:before { content: \"\\eb83\"; }\r\n.slc-outinbox-full:before { content: \"\\eb84\"; }\r\n.slc-outinbox:before { content: \"\\eb85\"; }\r\n.slc-outindent:before { content: \"\\eb86\"; }\r\n.slc-outinfo-circle:before { content: \"\\eb87\"; }\r\n.slc-outkeyboard:before { content: \"\\eb88\"; }\r\n.slc-outlabel:before { content: \"\\eb89\"; }\r\n.slc-outlandmark:before { content: \"\\eb8a\"; }\r\n.slc-outlayers:before { content: \"\\eb8b\"; }\r\n.slc-outletter-bold:before { content: \"\\eb8c\"; }\r\n.slc-outletter-italic:before { content: \"\\eb8d\"; }\r\n.slc-outletter-underline:before { content: \"\\eb8e\"; }\r\n.slc-outlife-saver:before { content: \"\\eb8f\"; }\r\n.slc-outlightbulb:before { content: \"\\eb90\"; }\r\n.slc-outlink:before { content: \"\\eb91\"; }\r\n.slc-outlist-music:before { content: \"\\eb92\"; }\r\n.slc-outlist:before { content: \"\\eb93\"; }\r\n.slc-outlock-open:before { content: \"\\eb94\"; }\r\n.slc-outlock-time:before { content: \"\\eb95\"; }\r\n.slc-outlock:before { content: \"\\eb96\"; }\r\n.slc-outmail-box:before { content: \"\\eb97\"; }\r\n.slc-outmap-pin-alt:before { content: \"\\eb98\"; }\r\n.slc-outmap-pin:before { content: \"\\eb99\"; }\r\n.slc-outmessage-caption:before { content: \"\\eb9a\"; }\r\n.slc-outmessage-dots:before { content: \"\\eb9b\"; }\r\n.slc-outmessages:before { content: \"\\eb9c\"; }\r\n.slc-outmicrophone:before { content: \"\\eb9d\"; }\r\n.slc-outminimize:before { content: \"\\eb9e\"; }\r\n.slc-outminus:before { content: \"\\eb9f\"; }\r\n.slc-outmobile-phone:before { content: \"\\eba0\"; }\r\n.slc-outmoon:before { content: \"\\eba1\"; }\r\n.slc-outnewspaper:before { content: \"\\eba2\"; }\r\n.slc-outordered-list:before { content: \"\\eba3\"; }\r\n.slc-outoutdent:before { content: \"\\eba4\"; }\r\n.slc-outpalette:before { content: \"\\eba5\"; }\r\n.slc-outpaper-clip:before { content: \"\\eba6\"; }\r\n.slc-outpaper-plane:before { content: \"\\eba7\"; }\r\n.slc-outparagraph:before { content: \"\\eba8\"; }\r\n.slc-outpause:before { content: \"\\eba9\"; }\r\n.slc-outpen-nib:before { content: \"\\ebaa\"; }\r\n.slc-outpen:before { content: \"\\ebab\"; }\r\n.slc-outphone:before { content: \"\\ebac\"; }\r\n.slc-outplay:before { content: \"\\ebad\"; }\r\n.slc-outplus:before { content: \"\\ebae\"; }\r\n.slc-outprinter:before { content: \"\\ebaf\"; }\r\n.slc-outprofile-card:before { content: \"\\ebb0\"; }\r\n.slc-outquestion-circle:before { content: \"\\ebb1\"; }\r\n.slc-outquote:before { content: \"\\ebb2\"; }\r\n.slc-outreceipt:before { content: \"\\ebb3\"; }\r\n.slc-outrectangle-list:before { content: \"\\ebb4\"; }\r\n.slc-outredo:before { content: \"\\ebb5\"; }\r\n.slc-outrefresh:before { content: \"\\ebb6\"; }\r\n.slc-outreply-all:before { content: \"\\ebb7\"; }\r\n.slc-outreply:before { content: \"\\ebb8\"; }\r\n.slc-outrestore-window:before { content: \"\\ebb9\"; }\r\n.slc-outrocket:before { content: \"\\ebba\"; }\r\n.slc-outruler-combined:before { content: \"\\ebbb\"; }\r\n.slc-outsale-percent:before { content: \"\\ebbc\"; }\r\n.slc-outscale-balanced:before { content: \"\\ebbd\"; }\r\n.slc-outsearch:before { content: \"\\ebbe\"; }\r\n.slc-outshare-all:before { content: \"\\ebbf\"; }\r\n.slc-outshare-nodes:before { content: \"\\ebc0\"; }\r\n.slc-outshield-check:before { content: \"\\ebc1\"; }\r\n.slc-outshield:before { content: \"\\ebc2\"; }\r\n.slc-outshopping-bag:before { content: \"\\ebc3\"; }\r\n.slc-outshuffle:before { content: \"\\ebc4\"; }\r\n.slc-outsort-horizontal:before { content: \"\\ebc5\"; }\r\n.slc-outsort:before { content: \"\\ebc6\"; }\r\n.slc-outstar-half-stroke:before { content: \"\\ebc7\"; }\r\n.slc-outstar-half:before { content: \"\\ebc8\"; }\r\n.slc-outstar:before { content: \"\\ebc9\"; }\r\n.slc-outstore:before { content: \"\\ebca\"; }\r\n.slc-outsun:before { content: \"\\ebcb\"; }\r\n.slc-outswatchbook:before { content: \"\\ebcc\"; }\r\n.slc-outtable-column:before { content: \"\\ebcd\"; }\r\n.slc-outtable-row:before { content: \"\\ebce\"; }\r\n.slc-outtablet:before { content: \"\\ebcf\"; }\r\n.slc-outtag:before { content: \"\\ebd0\"; }\r\n.slc-outterminal:before { content: \"\\ebd1\"; }\r\n.slc-outtext-size:before { content: \"\\ebd2\"; }\r\n.slc-outtext-slash:before { content: \"\\ebd3\"; }\r\n.slc-outthumbs-down:before { content: \"\\ebd4\"; }\r\n.slc-outthumbs-up:before { content: \"\\ebd5\"; }\r\n.slc-outticket:before { content: \"\\ebd6\"; }\r\n.slc-outtrash-bin:before { content: \"\\ebd7\"; }\r\n.slc-outtruck:before { content: \"\\ebd8\"; }\r\n.slc-outundo:before { content: \"\\ebd9\"; }\r\n.slc-outupload:before { content: \"\\ebda\"; }\r\n.slc-outuser-add:before { content: \"\\ebdb\"; }\r\n.slc-outuser-circle:before { content: \"\\ebdc\"; }\r\n.slc-outuser-edit:before { content: \"\\ebdd\"; }\r\n.slc-outuser-headset:before { content: \"\\ebde\"; }\r\n.slc-outuser-remove:before { content: \"\\ebdf\"; }\r\n.slc-outuser-settings:before { content: \"\\ebe0\"; }\r\n.slc-outuser:before { content: \"\\ebe1\"; }\r\n.slc-outusers-group:before { content: \"\\ebe2\"; }\r\n.slc-outusers:before { content: \"\\ebe3\"; }\r\n.slc-outvideo-camera:before { content: \"\\ebe4\"; }\r\n.slc-outvolume-down:before { content: \"\\ebe5\"; }\r\n.slc-outvolume-up:before { content: \"\\ebe6\"; }\r\n.slc-outwallet:before { content: \"\\ebe7\"; }\r\n.slc-outwand-magic-sparkles:before { content: \"\\ebe8\"; }\r\n.slc-outwindow:before { content: \"\\ebe9\"; }\r\n.slc-outzoom-in:before { content: \"\\ebea\"; }\r\n.slc-outzoom-out:before { content: \"\\ebeb\"; }\r\n\r\n",
    "size": 1462072
  },
  "EventManagerDocumentation": {
    "name": "EventManagerDocumentation",
    "category": "AppComponents",
    "categoryType": "Visual",
    "js": "class EventManagerDocumentation extends HTMLElement {\n  constructor(props) {\n    super();\n    slice.attachTemplate(this);\n    slice.controller.setComponentProps(this, props);\n    this.debuggerProps = [];\n  }\n\n  async init() {\n    this.markdownPath = \"event-manager.md\";\n    this.markdownContent = \"---\\ntitle: EventManager\\nroute: /Documentation/Structural/EventManager\\nnavLabel: Events\\nsection: Getting Started\\ngroup: Events\\norder: 20\\ndescription: Lightweight pub/sub for component and app events.\\ncomponent: EventManagerDocumentation\\ntags: [events, pubsub, lifecycle, cleanup]\\n---\\n\\n# EventManager\\n\\n## Overview\\nEventManager provides a lightweight pub/sub system for Slice.js. It supports global subscriptions,\\ncomponent-bound subscriptions with auto-cleanup, and one-time listeners. It is designed for\\ncross-cutting signals and decoupled communication between components and services.\\n\\n## When to Use\\n- App-level signals (app:ready, user:login, notification:show)\\n- Decoupled UI updates (service emits, UI listens)\\n- One-time bootstrap actions\\n\\n## When Not to Use\\n- Shared, persistent state: use ContextManager instead\\n- High-frequency real-time data: use dedicated data streams\\n\\n## Enable\\n```json\\n{\\n  \\\"events\\\": { \\\"enabled\\\": true }\\n}\\n```\\n\\n## Events UI (Optional)\\nYou can enable the EventManager debug panel with a keyboard shortcut.\\n\\n```json title=\\\"sliceConfig.json\\\"\\n{\\n  \\\"events\\\": {\\n    \\\"enabled\\\": true,\\n    \\\"ui\\\": {\\n      \\\"enabled\\\": true,\\n      \\\"shortcut\\\": \\\"alt+shift+e\\\"\\n    }\\n  }\\n}\\n```\\n\\n## Concepts\\n- Event names are strings, typically namespaced (`domain:action`).\\n- Subscriptions can be global or component-bound.\\n- Component-bound subscriptions are auto-removed when the component is destroyed.\\n\\n## API Reference\\n| Method | Signature | Notes |\\n| --- | --- | --- |\\n| `subscribe` | `(eventName, callback, options?)` | Auto-cleanup if `options.component` set |\\n| `subscribeOnce` | `(eventName, callback, options?)` | Auto-unsubscribe after first emit |\\n| `unsubscribe` | `(eventName, subscriptionId)` | Returns boolean |\\n| `emit` | `(eventName, data?)` | Emits to all subscribers |\\n| `bind` | `(component)` | Returns component-bound API |\\n| `hasSubscribers` | `(eventName)` | Diagnostics only |\\n| `subscriberCount` | `(eventName)` | Diagnostics only |\\n| `clear` | `()` | Clears all subscriptions |\\n\\n## Usage Patterns\\n```javascript title=\\\"Component-bound subscription in init() (recommended)\\\"\\nclass Navbar extends HTMLElement {\\n  constructor(props) {\\n    super();\\n    slice.attachTemplate(this);\\n    slice.controller.setComponentProps(this, props);\\n  }\\n\\n  async init() {\\n    this.events = slice.events.bind(this);\\n    this.events.subscribe(\\\"user:logout\\\", () => this.resetUI());\\n  }\\n\\n  resetUI() {\\n    // ...\\n  }\\n}\\n```\\n\\n```javascript title=\\\"Component-bound without bind() in init()\\\"\\nclass Navbar extends HTMLElement {\\n  async init() {\\n    slice.events.subscribe(\\n      \\\"user:logout\\\",\\n      () => this.resetUI(),\\n      { component: this }\\n    );\\n  }\\n}\\n```\\n\\n```javascript title=\\\"One-time initialization in init()\\\"\\nclass AppShell extends HTMLElement {\\n  async init() {\\n    slice.events.subscribeOnce(\\\"app:ready\\\", () => {\\n      console.log(\\\"App ready\\\");\\n    });\\n  }\\n}\\n```\\n\\n```javascript title=\\\"Global notification from a service\\\"\\nclass NotificationService {\\n  notify(message, type = \\\"success\\\") {\\n    slice.events.emit(\\\"notification:show\\\", { type, message });\\n  }\\n}\\n```\\n\\n## Component Integration\\n```javascript title=\\\"Service emits, UI listens\\\"\\nclass NotificationService {\\n  notify(message, type = \\\"info\\\") {\\n    slice.events.emit(\\\"notification:show\\\", { message, type });\\n  }\\n}\\n\\nclass Toasts extends HTMLElement {\\n  constructor(props) {\\n    super();\\n    slice.attachTemplate(this);\\n    slice.controller.setComponentProps(this, props);\\n  }\\n\\n  async init() {\\n    this.events = slice.events.bind(this);\\n    this.events.subscribe(\\\"notification:show\\\", ({ message, type }) => {\\n      this.showToast(message, type);\\n    });\\n  }\\n}\\n```\\n\\n## Implementation Recipe\\n:::steps\\n1. Choose a namespaced event name (e.g., `cart:updated`).\\n2. Emit the event where the change happens.\\n3. Subscribe in the UI or other consumers using `bind()`.\\n4. Use `subscribeOnce` for bootstrapping or single-run tasks.\\n:::\\n\\n## Best Practices\\n:::tip\\nUse namespaced event names. Avoid generic names like `update` or `change`.\\n:::\\n\\n:::tip\\nKeep payloads small and serializable when possible.\\n:::\\n\\n:::tip\\nPrefer `bind()` for components. It prevents leaks by default.\\n:::\\n\\n:::tip\\nUse EventManager for signals, not for shared state. Pair with ContextManager when state must persist.\\n:::\\n\\n## Gotchas\\n:::warning\\nClearing a container does not remove subscriptions. Use component-bound subscriptions or manual\\n`unsubscribe` calls.\\n:::\\n\\n:::warning\\nAvoid using EventManager as a data store. It does not retain state.\\n:::\\n\\n## Diagnostics\\n```javascript title=\\\"Check if anyone is listening\\\"\\nif (slice.events.hasSubscribers(\\\"cart:updated\\\")) {\\n  slice.events.emit(\\\"cart:updated\\\", { items: 3 });\\n}\\n```\\n\\n## FAQ\\n:::details title=\\\"Should I use EventManager for shared state?\\\"\\nNo. Use ContextManager for shared state. EventManager is for ephemeral signals.\\n:::\\n\\n:::details title=\\\"What happens if events are disabled?\\\"\\nSlice.js provides a no-op implementation so calls to `slice.events` are safe.\\n:::\\n\\n:::details title=\\\"Do I need to unsubscribe manually?\\\"\\nOnly if you are not using `bind()` or `options.component`. Component-bound subscriptions auto-clean.\\n:::\\n\\n:::details title=\\\"Can I debug event usage?\\\"\\nUse `hasSubscribers` or `subscriberCount` for diagnostics in development.\\n:::\\n\";\n    if (true) {\n      this.setupCopyButton();\n    }\n      {\n         const container = this.querySelector('[data-block-id=\"doc-block-1\"]');\n         if (container) {\n            const code = await slice.build('CodeVisualizer', {\n               value: \"{\\n  \\\"events\\\": { \\\"enabled\\\": true }\\n}\",\n               language: \"json\"\n            });\n            if (null) {\n               const label = document.createElement('div');\n               label.classList.add('code-block-title');\n               label.textContent = null;\n               container.appendChild(label);\n            }\n            container.appendChild(code);\n         }\n      }\n      {\n         const container = this.querySelector('[data-block-id=\"doc-block-2\"]');\n         if (container) {\n            const code = await slice.build('CodeVisualizer', {\n               value: \"{\\n  \\\"events\\\": {\\n    \\\"enabled\\\": true,\\n    \\\"ui\\\": {\\n      \\\"enabled\\\": true,\\n      \\\"shortcut\\\": \\\"alt+shift+e\\\"\\n    }\\n  }\\n}\",\n               language: \"json\"\n            });\n            if (\"sliceConfig.json\") {\n               const label = document.createElement('div');\n               label.classList.add('code-block-title');\n               label.textContent = \"sliceConfig.json\";\n               container.appendChild(label);\n            }\n            container.appendChild(code);\n         }\n      }\n      {\n         const container = this.querySelector('[data-block-id=\"doc-block-3\"]');\n         if (container) {\n            const lines = [\"| Method | Signature | Notes |\",\"| --- | --- | --- |\",\"| `subscribe` | `(eventName, callback, options?)` | Auto-cleanup if `options.component` set |\",\"| `subscribeOnce` | `(eventName, callback, options?)` | Auto-unsubscribe after first emit |\",\"| `unsubscribe` | `(eventName, subscriptionId)` | Returns boolean |\",\"| `emit` | `(eventName, data?)` | Emits to all subscribers |\",\"| `bind` | `(component)` | Returns component-bound API |\",\"| `hasSubscribers` | `(eventName)` | Diagnostics only |\",\"| `subscriberCount` | `(eventName)` | Diagnostics only |\",\"| `clear` | `()` | Clears all subscriptions |\"];\n            const clean = (line) => {\n               let value = line.trim();\n               if (value.startsWith('|')) {\n                  value = value.slice(1);\n               }\n               if (value.endsWith('|')) {\n                  value = value.slice(0, -1);\n               }\n               return value.split('|').map((cell) => cell.trim());\n            };\n\n            const formatCell = (text) => {\n               let output = text\n                  .replace(/&/g, '&amp;')\n                  .replace(/</g, '&lt;')\n                  .replace(/>/g, '&gt;');\n\n               const applyBold = (input) => {\n                  let result = '';\n                  let index = 0;\n                  while (index < input.length) {\n                     const start = input.indexOf('**', index);\n                     if (start === -1) {\n                        result += input.slice(index);\n                        break;\n                     }\n                     const end = input.indexOf('**', start + 2);\n                     if (end === -1) {\n                        result += input.slice(index);\n                        break;\n                     }\n                     result += input.slice(index, start) + '<strong>' + input.slice(start + 2, end) + '</strong>';\n                     index = end + 2;\n                  }\n                  return result;\n               };\n\n               const applyInlineCode = (input) => {\n                  const parts = input.split(String.fromCharCode(96));\n                  if (parts.length === 1) return input;\n                  return parts\n                     .map((part, idx) => (idx % 2 === 1 ? '<code>' + part + '</code>' : part))\n                     .join('');\n               };\n\n               output = applyBold(output);\n               output = applyInlineCode(output);\n               return output;\n            };\n\n            const headers = lines.length > 0 ? clean(lines[0]) : [];\n            const rows = lines.slice(2).map((line) => clean(line).map((cell) => formatCell(cell)));\n            const table = await slice.build('Table', { headers, rows });\n            container.appendChild(table);\n         }\n      }\n      {\n         const container = this.querySelector('[data-block-id=\"doc-block-4\"]');\n         if (container) {\n            const code = await slice.build('CodeVisualizer', {\n               value: \"class Navbar extends HTMLElement {\\n  constructor(props) {\\n    super();\\n    slice.attachTemplate(this);\\n    slice.controller.setComponentProps(this, props);\\n  }\\n\\n  async init() {\\n    this.events = slice.events.bind(this);\\n    this.events.subscribe(\\\"user:logout\\\", () => this.resetUI());\\n  }\\n\\n  resetUI() {\\n    // ...\\n  }\\n}\",\n               language: \"javascript\"\n            });\n            if (\"Component-bound subscription in init() (recommended)\") {\n               const label = document.createElement('div');\n               label.classList.add('code-block-title');\n               label.textContent = \"Component-bound subscription in init() (recommended)\";\n               container.appendChild(label);\n            }\n            container.appendChild(code);\n         }\n      }\n      {\n         const container = this.querySelector('[data-block-id=\"doc-block-5\"]');\n         if (container) {\n            const code = await slice.build('CodeVisualizer', {\n               value: \"class Navbar extends HTMLElement {\\n  async init() {\\n    slice.events.subscribe(\\n      \\\"user:logout\\\",\\n      () => this.resetUI(),\\n      { component: this }\\n    );\\n  }\\n}\",\n               language: \"javascript\"\n            });\n            if (\"Component-bound without bind() in init()\") {\n               const label = document.createElement('div');\n               label.classList.add('code-block-title');\n               label.textContent = \"Component-bound without bind() in init()\";\n               container.appendChild(label);\n            }\n            container.appendChild(code);\n         }\n      }\n      {\n         const container = this.querySelector('[data-block-id=\"doc-block-6\"]');\n         if (container) {\n            const code = await slice.build('CodeVisualizer', {\n               value: \"class AppShell extends HTMLElement {\\n  async init() {\\n    slice.events.subscribeOnce(\\\"app:ready\\\", () => {\\n      console.log(\\\"App ready\\\");\\n    });\\n  }\\n}\",\n               language: \"javascript\"\n            });\n            if (\"One-time initialization in init()\") {\n               const label = document.createElement('div');\n               label.classList.add('code-block-title');\n               label.textContent = \"One-time initialization in init()\";\n               container.appendChild(label);\n            }\n            container.appendChild(code);\n         }\n      }\n      {\n         const container = this.querySelector('[data-block-id=\"doc-block-7\"]');\n         if (container) {\n            const code = await slice.build('CodeVisualizer', {\n               value: \"class NotificationService {\\n  notify(message, type = \\\"success\\\") {\\n    slice.events.emit(\\\"notification:show\\\", { type, message });\\n  }\\n}\",\n               language: \"javascript\"\n            });\n            if (\"Global notification from a service\") {\n               const label = document.createElement('div');\n               label.classList.add('code-block-title');\n               label.textContent = \"Global notification from a service\";\n               container.appendChild(label);\n            }\n            container.appendChild(code);\n         }\n      }\n      {\n         const container = this.querySelector('[data-block-id=\"doc-block-8\"]');\n         if (container) {\n            const code = await slice.build('CodeVisualizer', {\n               value: \"class NotificationService {\\n  notify(message, type = \\\"info\\\") {\\n    slice.events.emit(\\\"notification:show\\\", { message, type });\\n  }\\n}\\n\\nclass Toasts extends HTMLElement {\\n  constructor(props) {\\n    super();\\n    slice.attachTemplate(this);\\n    slice.controller.setComponentProps(this, props);\\n  }\\n\\n  async init() {\\n    this.events = slice.events.bind(this);\\n    this.events.subscribe(\\\"notification:show\\\", ({ message, type }) => {\\n      this.showToast(message, type);\\n    });\\n  }\\n}\",\n               language: \"javascript\"\n            });\n            if (\"Service emits, UI listens\") {\n               const label = document.createElement('div');\n               label.classList.add('code-block-title');\n               label.textContent = \"Service emits, UI listens\";\n               container.appendChild(label);\n            }\n            container.appendChild(code);\n         }\n      }\n      {\n         const container = this.querySelector('[data-block-id=\"doc-block-9\"]');\n         if (container) {\n            const code = await slice.build('CodeVisualizer', {\n               value: \"if (slice.events.hasSubscribers(\\\"cart:updated\\\")) {\\n  slice.events.emit(\\\"cart:updated\\\", { items: 3 });\\n}\",\n               language: \"javascript\"\n            });\n            if (\"Check if anyone is listening\") {\n               const label = document.createElement('div');\n               label.classList.add('code-block-title');\n               label.textContent = \"Check if anyone is listening\";\n               container.appendChild(label);\n            }\n            container.appendChild(code);\n         }\n      }\n      {\n         const container = this.querySelector('[data-block-id=\"doc-block-10\"]');\n         if (container) {\n            const details = await slice.build('Details', { title: \"Should I use EventManager for shared state?\", text: \"No. Use ContextManager for shared state. EventManager is for ephemeral signals.\" });\n            container.appendChild(details);\n         }\n      }\n      {\n         const container = this.querySelector('[data-block-id=\"doc-block-11\"]');\n         if (container) {\n            const details = await slice.build('Details', { title: \"What happens if events are disabled?\", text: \"Slice.js provides a no-op implementation so calls to `slice.events` are safe.\" });\n            container.appendChild(details);\n         }\n      }\n      {\n         const container = this.querySelector('[data-block-id=\"doc-block-12\"]');\n         if (container) {\n            const details = await slice.build('Details', { title: \"Do I need to unsubscribe manually?\", text: \"Only if you are not using `bind()` or `options.component`. Component-bound subscriptions auto-clean.\" });\n            container.appendChild(details);\n         }\n      }\n      {\n         const container = this.querySelector('[data-block-id=\"doc-block-13\"]');\n         if (container) {\n            const details = await slice.build('Details', { title: \"Can I debug event usage?\", text: \"Use `hasSubscribers` or `subscriberCount` for diagnostics in development.\" });\n            container.appendChild(details);\n         }\n      }\n  }\n\n  async update() {\n    // Refresh dynamic content here if needed\n  }\n\n  beforeDestroy() {\n    // Cleanup timers, listeners, or pending work here\n  }\n\n  async setupCopyButton() {\n    const container = this.querySelector('[data-copy-md]');\n    if (!container) return;\n\n    const copyMenu = await slice.build('CopyMarkdownMenu', {\n      markdownPath: this.markdownPath,\n      markdownContent: this.markdownContent,\n      label: '❐'\n    });\n\n    container.appendChild(copyMenu);\n  }\n\n  async copyMarkdown() {}\n}\n\nwindow.EventManagerDocumentation = EventManagerDocumentation;\ncustomElements.define('slice-eventmanagerdocumentation', EventManagerDocumentation);\n\nreturn EventManagerDocumentation;",
    "externalDependencies": {},
    "componentDependencies": [
      "CodeVisualizer",
      "Table",
      "Details",
      "CopyMarkdownMenu"
    ],
    "html": "<div class=\"documentation-content eventmanagerdocumentation\">\n\n<div class=\"doc-title-bar\">\n  <h1 id=\"eventmanager\">\n    <span class=\"doc-title-text\">EventManager</span>\n    <span class=\"copy-md-slot\" data-copy-md></span>\n  </h1>\n</div>\n<h2 id=\"overview\">Overview</h2>\n<p>EventManager provides a lightweight pub/sub system for Slice.js. It supports global subscriptions, component-bound subscriptions with auto-cleanup, and one-time listeners. It is designed for cross-cutting signals and decoupled communication between components and services.</p>\n<h2 id=\"when-to-use\">When to Use</h2>\n<ul><li>App-level signals (app:ready, user:login, notification:show)</li><li>Decoupled UI updates (service emits, UI listens)</li><li>One-time bootstrap actions</li></ul>\n<h2 id=\"when-not-to-use\">When Not to Use</h2>\n<ul><li>Shared, persistent state: use ContextManager instead</li><li>High-frequency real-time data: use dedicated data streams</li></ul>\n<h2 id=\"enable\">Enable</h2>\n<div class=\"code-block\" data-block-id=\"doc-block-1\"></div>\n<h2 id=\"events-ui-optional\">Events UI (Optional)</h2>\n<p>You can enable the EventManager debug panel with a keyboard shortcut.</p>\n<div class=\"code-block\" data-block-id=\"doc-block-2\"></div>\n<h2 id=\"concepts\">Concepts</h2>\n<ul><li>Event names are strings, typically namespaced (<code>domain:action</code>).</li><li>Subscriptions can be global or component-bound.</li><li>Component-bound subscriptions are auto-removed when the component is destroyed.</li></ul>\n<h2 id=\"api-reference\">API Reference</h2>\n<div class=\"table-block\" data-block-id=\"doc-block-3\"></div>\n<h2 id=\"usage-patterns\">Usage Patterns</h2>\n<div class=\"code-block\" data-block-id=\"doc-block-4\"></div>\n<div class=\"code-block\" data-block-id=\"doc-block-5\"></div>\n<div class=\"code-block\" data-block-id=\"doc-block-6\"></div>\n<div class=\"code-block\" data-block-id=\"doc-block-7\"></div>\n<h2 id=\"component-integration\">Component Integration</h2>\n<div class=\"code-block\" data-block-id=\"doc-block-8\"></div>\n<h2 id=\"implementation-recipe\">Implementation Recipe</h2>\n<ol class=\"steps\"><li>Choose a namespaced event name (e.g., <code>cart:updated</code>).</li><li>Emit the event where the change happens.</li><li>Subscribe in the UI or other consumers using <code>bind()</code>.</li><li>Use <code>subscribeOnce</code> for bootstrapping or single-run tasks.</li></ol>\n<h2 id=\"best-practices\">Best Practices</h2>\n<div class=\"callout callout-tip\">Use namespaced event names. Avoid generic names like <code>update</code> or <code>change</code>.</div>\n<div class=\"callout callout-tip\">Keep payloads small and serializable when possible.</div>\n<div class=\"callout callout-tip\">Prefer <code>bind()</code> for components. It prevents leaks by default.</div>\n<div class=\"callout callout-tip\">Use EventManager for signals, not for shared state. Pair with ContextManager when state must persist.</div>\n<h2 id=\"gotchas\">Gotchas</h2>\n<div class=\"callout callout-warning\">Clearing a container does not remove subscriptions. Use component-bound subscriptions or manual\n<code>unsubscribe</code> calls.</div>\n<div class=\"callout callout-warning\">Avoid using EventManager as a data store. It does not retain state.</div>\n<h2 id=\"diagnostics\">Diagnostics</h2>\n<div class=\"code-block\" data-block-id=\"doc-block-9\"></div>\n<h2 id=\"faq\">FAQ</h2>\n<div class=\"details-block\" data-block-id=\"doc-block-10\"></div>\n<div class=\"details-block\" data-block-id=\"doc-block-11\"></div>\n<div class=\"details-block\" data-block-id=\"doc-block-12\"></div>\n<div class=\"details-block\" data-block-id=\"doc-block-13\"></div>\n</div>\n",
    "css": "/* EventManager Documentation Component Styles */\n\nslice-eventmanagerdocumentation {\n  color: var(--font-primary-color);\n  display: block;\n  max-width: 1200px;\n  margin: 0 auto;\n  padding: 20px;\n  line-height: 1.6;\n}\n\nslice-eventmanagerdocumentation h1,\nslice-eventmanagerdocumentation h2,\nslice-eventmanagerdocumentation h3,\nslice-eventmanagerdocumentation h4 {\n  margin-top: 1.5em;\n  margin-bottom: 0.5em;\n}\n\nslice-eventmanagerdocumentation h1 {\n  text-align: center;\n  border-bottom: 3px solid var(--primary-color);\n  padding-bottom: 12px;\n}\n\nslice-eventmanagerdocumentation h2 {\n  border-bottom: 1px solid var(--primary-color-shade);\n  padding-bottom: 8px;\n}\n\nslice-eventmanagerdocumentation p {\n  margin: 1em 0;\n}\n\nslice-eventmanagerdocumentation ul {\n  margin: 1em 0;\n  padding-left: 2em;\n}\n\nslice-eventmanagerdocumentation li {\n  margin-bottom: 0.5em;\n}\n\nslice-eventmanagerdocumentation code {\n  font-family: monospace;\n  background-color: var(--secondary-background-color);\n  padding: 0.2em 0.4em;\n  border-radius: 3px;\n  font-size: 0.9em;\n}\n\nslice-eventmanagerdocumentation .event-config-example,\nslice-eventmanagerdocumentation .basic-example,\nslice-eventmanagerdocumentation .component-binding-example,\nslice-eventmanagerdocumentation .component-options-example,\nslice-eventmanagerdocumentation .subscribe-once-example,\nslice-eventmanagerdocumentation .manual-cleanup-example,\nslice-eventmanagerdocumentation .event-driven-ui-example {\n  margin: 1.5em 0;\n}\n\nslice-eventmanagerdocumentation strong {\n  color: var(--primary-color);\n}\n\nslice-eventmanagerdocumentation .faq-section {\n  margin: 2em 0;\n}\n\nslice-eventmanagerdocumentation .faq-section slice-details {\n  margin-bottom: 1em;\n}\n\n@media (max-width: 768px) {\n  slice-eventmanagerdocumentation {\n    padding: 15px;\n  }\n}\n",
    "size": 22879
  },
  "Details": {
    "name": "Details",
    "category": "Visual",
    "categoryType": "Visual",
    "js": "class Details extends HTMLElement {\r\n\r\n   static props = {\r\n      title: { \r\n         type: 'string', \r\n         default: '', \r\n         required: false \r\n      },\r\n      text: { \r\n         type: 'string', \r\n         default: '', \r\n         required: false \r\n      }\r\n   };\r\n\r\n   constructor(props) {\r\n      super();\r\n      slice.attachTemplate(this);\r\n\r\n      this.$detailsTitle = this.querySelector('.details_title');\r\n      this.$detailsText = this.querySelector('.details_text');\r\n      this.$details = this.querySelector('.full_details');\r\n      this.$summary = this.querySelector('.details_summary');\r\n      this.$container = this.querySelector('.details_container');\r\n\r\n      this.$summary.addEventListener('click', () => {\r\n         this.toggleDetails();\r\n      });\r\n\r\n      slice.controller.setComponentProps(this, props);\r\n   }\r\n\r\n   init() {\r\n      // Component initialization\r\n   }\r\n\r\n   toggleDetails() {\r\n      const isOpen = this.$container.classList.toggle('details_open');\r\n      const symbol = this.$summary.querySelector('.symbol');\r\n\r\n      if (isOpen) {\r\n         symbol.classList.remove('plus');\r\n         symbol.classList.add('minus');\r\n\r\n         // Obtener la altura total del contenedor\r\n         const fullHeight = this.$container.scrollHeight + 'px';\r\n\r\n         // Establecer la altura para iniciar la animación\r\n         this.$container.style.height = fullHeight;\r\n\r\n         // Después de la transición, ajustar la altura a 'auto'\r\n         this.$container.addEventListener('transitionend', function onTransitionEnd() {\r\n            this.style.height = 'auto';\r\n            this.removeEventListener('transitionend', onTransitionEnd);\r\n         });\r\n      } else {\r\n         symbol.classList.remove('minus');\r\n         symbol.classList.add('plus');\r\n\r\n         // Establecer la altura para iniciar la animación de cierre\r\n         this.$container.style.height = this.$container.scrollHeight + 'px';\r\n\r\n         // Forzar el reflujo para que la transición funcione\r\n         requestAnimationFrame(() => {\r\n            this.$container.style.height = '0';\r\n         });\r\n      }\r\n   }\r\n\r\n   get title() {\r\n      return this._title;\r\n   }\r\n\r\n   set title(value) {\r\n      this._title = value;\r\n      // ✅ Validar que value no sea null o undefined\r\n      if (value !== null && value !== undefined && this.$detailsTitle) {\r\n         this.$detailsTitle.textContent = value;\r\n      }\r\n   }\r\n\r\n   get text() {\r\n      return this._text;\r\n   }\r\n\r\n   set text(value) {\r\n      this._text = value;\r\n      // ✅ Validar que value no sea null o undefined\r\n      if (value !== null && value !== undefined && this.$detailsText) {\r\n         this.$detailsText.textContent = value;\r\n      }\r\n   }\r\n\r\n   addDetail(value) {\r\n      // ✅ Validar que value sea un nodo válido\r\n      if (!value || !(value instanceof Node)) {\r\n         console.warn('Details.addDetail: value must be a valid DOM Node');\r\n         return;\r\n      }\r\n      \r\n      if (this.$details) {\r\n         this.$details.appendChild(value);\r\n      }\r\n   }\r\n}\r\n\r\nwindow.Details = Details;\ncustomElements.define('slice-details', Details);\nreturn Details;",
    "externalDependencies": {},
    "componentDependencies": [],
    "html": "<div class=\"details_summary\">\r\n   <div class=\"symbol plus\"></div>\r\n   <span class=\"details_title\"></span>\r\n</div>\r\n<div class=\"details_container\">\r\n   <div class=\"full_details\">\r\n      <div class=\"details_text\"></div>\r\n   </div>\r\n</div>\r\n",
    "css": "slice-details {\r\n   font-family: var(--font-family);\r\n   color: var(--font-primary-color);\r\n}\r\n.details_summary {\r\n   cursor: pointer;\r\n   display: flex;\r\n   align-items: center;\r\n   border-bottom: var(--slice-border) solid var(--primary-color);\r\n   padding: 10px;\r\n}\r\n.details_summary .caret {\r\n   transform: rotate(-90deg);\r\n   margin-right: 10px;\r\n   color: var(--primary-color);\r\n}\r\n.details_title {\r\n   width: 100%;\r\n   font-weight: bold;\r\n}\r\n.details_text {\r\n   color: var(--font-secondary-color);\r\n}\r\n.details_container {\r\n   padding-left: 5px;\r\n   padding: 10px;\r\n   background-color: var(--secondary-background-color);\r\n   border-radius: var(--border-radius-slice);\r\n   visibility: hidden;\r\n   display: block;\r\n   height: 0; /* Inicia con altura 0 */\r\n   overflow: hidden;\r\n   transition:\r\n      height 0.3s ease,\r\n      visibility 0.3s ease; /* Agrega transición a height */\r\n}\r\n\r\n.details_open {\r\n   height: auto; /* Altura se ajustará automáticamente después de la transición */\r\n   visibility: visible;\r\n}\r\n\r\n.symbol {\r\n   border-radius: 5px;\r\n   width: 20px;\r\n   height: 20px;\r\n   position: relative;\r\n   transition: transform 0.3s ease;\r\n}\r\n\r\n.symbol::before,\r\n.symbol::after {\r\n   content: '';\r\n   position: absolute;\r\n   background-color: var(--primary-color);\r\n   width: 15px;\r\n   height: 2px;\r\n   top: 50%;\r\n   left: 0;\r\n   transition: transform 0.5s ease;\r\n}\r\n\r\n.symbol.plus::after {\r\n   transform: rotate(90deg);\r\n}\r\n\r\n.symbol.minus::before,\r\n.symbol.minus::after {\r\n   transform: rotate(360deg);\r\n}\r\n",
    "size": 4872
  },
  "ContextManagerDocumentation": {
    "name": "ContextManagerDocumentation",
    "category": "AppComponents",
    "categoryType": "Visual",
    "js": "class ContextManagerDocumentation extends HTMLElement {\n  constructor(props) {\n    super();\n    slice.attachTemplate(this);\n    slice.controller.setComponentProps(this, props);\n    this.debuggerProps = [];\n  }\n\n  async init() {\n    this.markdownPath = \"context-manager.md\";\n    this.markdownContent = \"---\\ntitle: ContextManager\\nroute: /Documentation/Structural/ContextManager\\nnavLabel: ContextManager\\nsection: Getting Started\\ngroup: State\\norder: 30\\ndescription: Shared state with watchers, selectors, and persistence.\\ncomponent: ContextManagerDocumentation\\ntags: [context, state, persistence]\\n---\\n\\n# ContextManager\\n\\n## Overview\\nContextManager provides shared state across components with watchers and optional persistence.\\nIt uses EventManager internally to notify watchers and supports selectors for efficient updates.\\n\\nEnable it in `sliceConfig.json` to use `slice.context`.\\n\\n## Enable ContextManager\\n```json title=\\\"sliceConfig.json\\\"\\n{\\n  \\\"context\\\": { \\\"enabled\\\": true }\\n}\\n```\\n\\n## Context UI (Optional)\\nYou can enable the ContextManager debug panel with a keyboard shortcut.\\n\\n```json title=\\\"sliceConfig.json\\\"\\n{\\n  \\\"context\\\": {\\n    \\\"enabled\\\": true,\\n    \\\"ui\\\": {\\n      \\\"enabled\\\": true,\\n      \\\"shortcut\\\": \\\"alt+shift+c\\\"\\n    }\\n  }\\n}\\n```\\n\\n## Core API\\n| Method | Signature | Returns | Notes |\\n| --- | --- | --- | --- |\\n| `create` | `(name, initialState = {}, options = {})` | `boolean` | Options include `persist`, `storageKey`. |\\n| `getState` | `(name)` | `any | null` | Returns current state or `null` if missing. |\\n| `setState` | `(name, updater)` | `void` | `updater` can be object or `(prev) => newState`. |\\n| `watch` | `(name, component, callback, selector?)` | `string | null` | Auto-cleanup via component sliceId. |\\n| `has` | `(name)` | `boolean` | Check if a context exists. |\\n| `destroy` | `(name)` | `boolean` | Removes a context and persisted storage. |\\n| `list` | `()` | `string[]` | Returns all context names. |\\n\\n## Context Options\\n| Option | Type | Default | Notes |\\n| --- | --- | --- | --- |\\n| `persist` | `boolean` | `false` | Saves state to `localStorage`. |\\n| `storageKey` | `string` | `slice_context_<name>` | Override persistence key. |\\n\\n## Create and Read\\n```javascript title=\\\"Create a context\\\"\\nslice.context.create('auth', {\\n  isLoggedIn: false,\\n  user: null\\n});\\n\\nconst authState = slice.context.getState('auth');\\nconsole.log(authState.isLoggedIn);\\n```\\n\\n## Watchers\\nWatchers are bound to components for auto-cleanup. Pass the component as the second argument.\\n\\n```javascript title=\\\"Watch with selector\\\"\\nclass AccountMenu extends HTMLElement {\\n  constructor(props) {\\n    super();\\n    slice.attachTemplate(this);\\n    slice.controller.setComponentProps(this, props);\\n  }\\n\\n  async init() {\\n    slice.context.watch(\\n      'auth',\\n      this,\\n      (isLoggedIn) => {\\n        this.classList.toggle('signed-in', isLoggedIn);\\n      },\\n      (state) => state.isLoggedIn\\n    );\\n  }\\n}\\n```\\n\\n## Selectors and Derived Data\\nSelectors run on every update and should be fast and side-effect free. ContextManager performs\\na shallow comparison of the selected value to decide when to notify.\\n\\n```javascript title=\\\"Derived value selector\\\"\\nslice.context.watch(\\n  'cart',\\n  this,\\n  (count) => {\\n    this.$badge.textContent = count;\\n  },\\n  (state) => state.items.length\\n);\\n```\\n\\n## Persistence\\nPersist a context to `localStorage` for session survival.\\n\\n```javascript title=\\\"Persistent context\\\"\\nslice.context.create(\\n  'preferences',\\n  { theme: 'light', locale: 'en' },\\n  { persist: true, storageKey: 'app:preferences' }\\n);\\n```\\n\\n## Functional Updates\\nUse functional updates when new state depends on previous state.\\n\\n```javascript title=\\\"Functional update\\\"\\nslice.context.setState('cart', (prev) => ({\\n  ...prev,\\n  items: [...prev.items, newItem],\\n  total: prev.total + newItem.price\\n}));\\n```\\n\\n## Service Singleton Example\\n```javascript title=\\\"Context access via singleton service\\\"\\nconst contextService = await slice.build('ImposterGameContextService', {\\n  sliceId: 'imposter-context-service'\\n});\\n\\nclass GameScreen extends HTMLElement {\\n  async init() {\\n    this.contextService = slice.getComponent('imposter-context-service');\\n    const config = this.contextService.getGameConfig();\\n    this.contextService.updateGameConfig({ step: 'reveal' });\\n  }\\n}\\n```\\n\\n## Best Practices\\n:::tip\\nKeep contexts small and focused by domain.\\n:::\\n\\n:::tip\\nUse selectors to reduce unnecessary updates.\\n:::\\n\\n:::tip\\nPrefer serializable state only. Avoid storing class instances or functions.\\n:::\\n\\n:::tip\\nUse a service singleton to encapsulate context reads/writes when multiple components share the same domain state.\\n:::\\n\\n## Gotchas\\n:::warning\\n`watch()` requires a component with a `sliceId`. Otherwise it returns `null`.\\n:::\\n\\n:::warning\\nPersist only small, serializable state.\\n:::\\n\";\n    if (true) {\n      this.setupCopyButton();\n    }\n      {\n         const container = this.querySelector('[data-block-id=\"doc-block-1\"]');\n         if (container) {\n            const code = await slice.build('CodeVisualizer', {\n               value: \"{\\n  \\\"context\\\": { \\\"enabled\\\": true }\\n}\",\n               language: \"json\"\n            });\n            if (\"sliceConfig.json\") {\n               const label = document.createElement('div');\n               label.classList.add('code-block-title');\n               label.textContent = \"sliceConfig.json\";\n               container.appendChild(label);\n            }\n            container.appendChild(code);\n         }\n      }\n      {\n         const container = this.querySelector('[data-block-id=\"doc-block-2\"]');\n         if (container) {\n            const code = await slice.build('CodeVisualizer', {\n               value: \"{\\n  \\\"context\\\": {\\n    \\\"enabled\\\": true,\\n    \\\"ui\\\": {\\n      \\\"enabled\\\": true,\\n      \\\"shortcut\\\": \\\"alt+shift+c\\\"\\n    }\\n  }\\n}\",\n               language: \"json\"\n            });\n            if (\"sliceConfig.json\") {\n               const label = document.createElement('div');\n               label.classList.add('code-block-title');\n               label.textContent = \"sliceConfig.json\";\n               container.appendChild(label);\n            }\n            container.appendChild(code);\n         }\n      }\n      {\n         const container = this.querySelector('[data-block-id=\"doc-block-3\"]');\n         if (container) {\n            const lines = [\"| Method | Signature | Returns | Notes |\",\"| --- | --- | --- | --- |\",\"| `create` | `(name, initialState = {}, options = {})` | `boolean` | Options include `persist`, `storageKey`. |\",\"| `getState` | `(name)` | `any | null` | Returns current state or `null` if missing. |\",\"| `setState` | `(name, updater)` | `void` | `updater` can be object or `(prev) => newState`. |\",\"| `watch` | `(name, component, callback, selector?)` | `string | null` | Auto-cleanup via component sliceId. |\",\"| `has` | `(name)` | `boolean` | Check if a context exists. |\",\"| `destroy` | `(name)` | `boolean` | Removes a context and persisted storage. |\",\"| `list` | `()` | `string[]` | Returns all context names. |\"];\n            const clean = (line) => {\n               let value = line.trim();\n               if (value.startsWith('|')) {\n                  value = value.slice(1);\n               }\n               if (value.endsWith('|')) {\n                  value = value.slice(0, -1);\n               }\n               return value.split('|').map((cell) => cell.trim());\n            };\n\n            const formatCell = (text) => {\n               let output = text\n                  .replace(/&/g, '&amp;')\n                  .replace(/</g, '&lt;')\n                  .replace(/>/g, '&gt;');\n\n               const applyBold = (input) => {\n                  let result = '';\n                  let index = 0;\n                  while (index < input.length) {\n                     const start = input.indexOf('**', index);\n                     if (start === -1) {\n                        result += input.slice(index);\n                        break;\n                     }\n                     const end = input.indexOf('**', start + 2);\n                     if (end === -1) {\n                        result += input.slice(index);\n                        break;\n                     }\n                     result += input.slice(index, start) + '<strong>' + input.slice(start + 2, end) + '</strong>';\n                     index = end + 2;\n                  }\n                  return result;\n               };\n\n               const applyInlineCode = (input) => {\n                  const parts = input.split(String.fromCharCode(96));\n                  if (parts.length === 1) return input;\n                  return parts\n                     .map((part, idx) => (idx % 2 === 1 ? '<code>' + part + '</code>' : part))\n                     .join('');\n               };\n\n               output = applyBold(output);\n               output = applyInlineCode(output);\n               return output;\n            };\n\n            const headers = lines.length > 0 ? clean(lines[0]) : [];\n            const rows = lines.slice(2).map((line) => clean(line).map((cell) => formatCell(cell)));\n            const table = await slice.build('Table', { headers, rows });\n            container.appendChild(table);\n         }\n      }\n      {\n         const container = this.querySelector('[data-block-id=\"doc-block-4\"]');\n         if (container) {\n            const lines = [\"| Option | Type | Default | Notes |\",\"| --- | --- | --- | --- |\",\"| `persist` | `boolean` | `false` | Saves state to `localStorage`. |\",\"| `storageKey` | `string` | `slice_context_<name>` | Override persistence key. |\"];\n            const clean = (line) => {\n               let value = line.trim();\n               if (value.startsWith('|')) {\n                  value = value.slice(1);\n               }\n               if (value.endsWith('|')) {\n                  value = value.slice(0, -1);\n               }\n               return value.split('|').map((cell) => cell.trim());\n            };\n\n            const formatCell = (text) => {\n               let output = text\n                  .replace(/&/g, '&amp;')\n                  .replace(/</g, '&lt;')\n                  .replace(/>/g, '&gt;');\n\n               const applyBold = (input) => {\n                  let result = '';\n                  let index = 0;\n                  while (index < input.length) {\n                     const start = input.indexOf('**', index);\n                     if (start === -1) {\n                        result += input.slice(index);\n                        break;\n                     }\n                     const end = input.indexOf('**', start + 2);\n                     if (end === -1) {\n                        result += input.slice(index);\n                        break;\n                     }\n                     result += input.slice(index, start) + '<strong>' + input.slice(start + 2, end) + '</strong>';\n                     index = end + 2;\n                  }\n                  return result;\n               };\n\n               const applyInlineCode = (input) => {\n                  const parts = input.split(String.fromCharCode(96));\n                  if (parts.length === 1) return input;\n                  return parts\n                     .map((part, idx) => (idx % 2 === 1 ? '<code>' + part + '</code>' : part))\n                     .join('');\n               };\n\n               output = applyBold(output);\n               output = applyInlineCode(output);\n               return output;\n            };\n\n            const headers = lines.length > 0 ? clean(lines[0]) : [];\n            const rows = lines.slice(2).map((line) => clean(line).map((cell) => formatCell(cell)));\n            const table = await slice.build('Table', { headers, rows });\n            container.appendChild(table);\n         }\n      }\n      {\n         const container = this.querySelector('[data-block-id=\"doc-block-5\"]');\n         if (container) {\n            const code = await slice.build('CodeVisualizer', {\n               value: \"slice.context.create('auth', {\\n  isLoggedIn: false,\\n  user: null\\n});\\n\\nconst authState = slice.context.getState('auth');\\nconsole.log(authState.isLoggedIn);\",\n               language: \"javascript\"\n            });\n            if (\"Create a context\") {\n               const label = document.createElement('div');\n               label.classList.add('code-block-title');\n               label.textContent = \"Create a context\";\n               container.appendChild(label);\n            }\n            container.appendChild(code);\n         }\n      }\n      {\n         const container = this.querySelector('[data-block-id=\"doc-block-6\"]');\n         if (container) {\n            const code = await slice.build('CodeVisualizer', {\n               value: \"class AccountMenu extends HTMLElement {\\n  constructor(props) {\\n    super();\\n    slice.attachTemplate(this);\\n    slice.controller.setComponentProps(this, props);\\n  }\\n\\n  async init() {\\n    slice.context.watch(\\n      'auth',\\n      this,\\n      (isLoggedIn) => {\\n        this.classList.toggle('signed-in', isLoggedIn);\\n      },\\n      (state) => state.isLoggedIn\\n    );\\n  }\\n}\",\n               language: \"javascript\"\n            });\n            if (\"Watch with selector\") {\n               const label = document.createElement('div');\n               label.classList.add('code-block-title');\n               label.textContent = \"Watch with selector\";\n               container.appendChild(label);\n            }\n            container.appendChild(code);\n         }\n      }\n      {\n         const container = this.querySelector('[data-block-id=\"doc-block-7\"]');\n         if (container) {\n            const code = await slice.build('CodeVisualizer', {\n               value: \"slice.context.watch(\\n  'cart',\\n  this,\\n  (count) => {\\n    this.$badge.textContent = count;\\n  },\\n  (state) => state.items.length\\n);\",\n               language: \"javascript\"\n            });\n            if (\"Derived value selector\") {\n               const label = document.createElement('div');\n               label.classList.add('code-block-title');\n               label.textContent = \"Derived value selector\";\n               container.appendChild(label);\n            }\n            container.appendChild(code);\n         }\n      }\n      {\n         const container = this.querySelector('[data-block-id=\"doc-block-8\"]');\n         if (container) {\n            const code = await slice.build('CodeVisualizer', {\n               value: \"slice.context.create(\\n  'preferences',\\n  { theme: 'light', locale: 'en' },\\n  { persist: true, storageKey: 'app:preferences' }\\n);\",\n               language: \"javascript\"\n            });\n            if (\"Persistent context\") {\n               const label = document.createElement('div');\n               label.classList.add('code-block-title');\n               label.textContent = \"Persistent context\";\n               container.appendChild(label);\n            }\n            container.appendChild(code);\n         }\n      }\n      {\n         const container = this.querySelector('[data-block-id=\"doc-block-9\"]');\n         if (container) {\n            const code = await slice.build('CodeVisualizer', {\n               value: \"slice.context.setState('cart', (prev) => ({\\n  ...prev,\\n  items: [...prev.items, newItem],\\n  total: prev.total + newItem.price\\n}));\",\n               language: \"javascript\"\n            });\n            if (\"Functional update\") {\n               const label = document.createElement('div');\n               label.classList.add('code-block-title');\n               label.textContent = \"Functional update\";\n               container.appendChild(label);\n            }\n            container.appendChild(code);\n         }\n      }\n      {\n         const container = this.querySelector('[data-block-id=\"doc-block-10\"]');\n         if (container) {\n            const code = await slice.build('CodeVisualizer', {\n               value: \"const contextService = await slice.build('ImposterGameContextService', {\\n  sliceId: 'imposter-context-service'\\n});\\n\\nclass GameScreen extends HTMLElement {\\n  async init() {\\n    this.contextService = slice.getComponent('imposter-context-service');\\n    const config = this.contextService.getGameConfig();\\n    this.contextService.updateGameConfig({ step: 'reveal' });\\n  }\\n}\",\n               language: \"javascript\"\n            });\n            if (\"Context access via singleton service\") {\n               const label = document.createElement('div');\n               label.classList.add('code-block-title');\n               label.textContent = \"Context access via singleton service\";\n               container.appendChild(label);\n            }\n            container.appendChild(code);\n         }\n      }\n  }\n\n  async update() {\n    // Refresh dynamic content here if needed\n  }\n\n  beforeDestroy() {\n    // Cleanup timers, listeners, or pending work here\n  }\n\n  async setupCopyButton() {\n    const container = this.querySelector('[data-copy-md]');\n    if (!container) return;\n\n    const copyMenu = await slice.build('CopyMarkdownMenu', {\n      markdownPath: this.markdownPath,\n      markdownContent: this.markdownContent,\n      label: '❐'\n    });\n\n    container.appendChild(copyMenu);\n  }\n\n  async copyMarkdown() {}\n}\n\nwindow.ContextManagerDocumentation = ContextManagerDocumentation;\ncustomElements.define('slice-contextmanagerdocumentation', ContextManagerDocumentation);\n\nreturn ContextManagerDocumentation;",
    "externalDependencies": {},
    "componentDependencies": [
      "CodeVisualizer",
      "Table",
      "CopyMarkdownMenu"
    ],
    "html": "<div class=\"documentation-content contextmanagerdocumentation\">\n\n<div class=\"doc-title-bar\">\n  <h1 id=\"contextmanager\">\n    <span class=\"doc-title-text\">ContextManager</span>\n    <span class=\"copy-md-slot\" data-copy-md></span>\n  </h1>\n</div>\n<h2 id=\"overview\">Overview</h2>\n<p>ContextManager provides shared state across components with watchers and optional persistence. It uses EventManager internally to notify watchers and supports selectors for efficient updates.</p>\n<p>Enable it in <code>sliceConfig.json</code> to use <code>slice.context</code>.</p>\n<h2 id=\"enable-contextmanager\">Enable ContextManager</h2>\n<div class=\"code-block\" data-block-id=\"doc-block-1\"></div>\n<h2 id=\"context-ui-optional\">Context UI (Optional)</h2>\n<p>You can enable the ContextManager debug panel with a keyboard shortcut.</p>\n<div class=\"code-block\" data-block-id=\"doc-block-2\"></div>\n<h2 id=\"core-api\">Core API</h2>\n<div class=\"table-block\" data-block-id=\"doc-block-3\"></div>\n<h2 id=\"context-options\">Context Options</h2>\n<div class=\"table-block\" data-block-id=\"doc-block-4\"></div>\n<h2 id=\"create-and-read\">Create and Read</h2>\n<div class=\"code-block\" data-block-id=\"doc-block-5\"></div>\n<h2 id=\"watchers\">Watchers</h2>\n<p>Watchers are bound to components for auto-cleanup. Pass the component as the second argument.</p>\n<div class=\"code-block\" data-block-id=\"doc-block-6\"></div>\n<h2 id=\"selectors-and-derived-data\">Selectors and Derived Data</h2>\n<p>Selectors run on every update and should be fast and side-effect free. ContextManager performs a shallow comparison of the selected value to decide when to notify.</p>\n<div class=\"code-block\" data-block-id=\"doc-block-7\"></div>\n<h2 id=\"persistence\">Persistence</h2>\n<p>Persist a context to <code>localStorage</code> for session survival.</p>\n<div class=\"code-block\" data-block-id=\"doc-block-8\"></div>\n<h2 id=\"functional-updates\">Functional Updates</h2>\n<p>Use functional updates when new state depends on previous state.</p>\n<div class=\"code-block\" data-block-id=\"doc-block-9\"></div>\n<h2 id=\"service-singleton-example\">Service Singleton Example</h2>\n<div class=\"code-block\" data-block-id=\"doc-block-10\"></div>\n<h2 id=\"best-practices\">Best Practices</h2>\n<div class=\"callout callout-tip\">Keep contexts small and focused by domain.</div>\n<div class=\"callout callout-tip\">Use selectors to reduce unnecessary updates.</div>\n<div class=\"callout callout-tip\">Prefer serializable state only. Avoid storing class instances or functions.</div>\n<div class=\"callout callout-tip\">Use a service singleton to encapsulate context reads/writes when multiple components share the same domain state.</div>\n<h2 id=\"gotchas\">Gotchas</h2>\n<div class=\"callout callout-warning\"><code>watch()</code> requires a component with a <code>sliceId</code>. Otherwise it returns <code>null</code>.</div>\n<div class=\"callout callout-warning\">Persist only small, serializable state.</div>\n</div>\n",
    "css": "/* ContextManager Documentation Component Styles */\n\nslice-contextmanagerdocumentation {\n  color: var(--font-primary-color);\n  display: block;\n  max-width: 1200px;\n  margin: 0 auto;\n  padding: 20px;\n  line-height: 1.6;\n}\n\nslice-contextmanagerdocumentation h1,\nslice-contextmanagerdocumentation h2,\nslice-contextmanagerdocumentation h3,\nslice-contextmanagerdocumentation h4 {\n  margin-top: 1.5em;\n  margin-bottom: 0.5em;\n}\n\nslice-contextmanagerdocumentation h1 {\n  text-align: center;\n  border-bottom: 3px solid var(--primary-color);\n  padding-bottom: 12px;\n}\n\nslice-contextmanagerdocumentation h2 {\n  border-bottom: 1px solid var(--primary-color-shade);\n  padding-bottom: 8px;\n}\n\nslice-contextmanagerdocumentation p {\n  margin: 1em 0;\n}\n\nslice-contextmanagerdocumentation ul {\n  margin: 1em 0;\n  padding-left: 2em;\n}\n\nslice-contextmanagerdocumentation li {\n  margin-bottom: 0.5em;\n}\n\nslice-contextmanagerdocumentation code {\n  font-family: monospace;\n  background-color: var(--secondary-background-color);\n  padding: 0.2em 0.4em;\n  border-radius: 3px;\n  font-size: 0.9em;\n}\n\nslice-contextmanagerdocumentation .context-config-example,\nslice-contextmanagerdocumentation .create-context-example,\nslice-contextmanagerdocumentation .watcher-example,\nslice-contextmanagerdocumentation .selector-example,\nslice-contextmanagerdocumentation .persistence-example,\nslice-contextmanagerdocumentation .functional-update-example,\nslice-contextmanagerdocumentation .shared-ui-example {\n  margin: 1.5em 0;\n}\n\nslice-contextmanagerdocumentation strong {\n  color: var(--primary-color);\n}\n\nslice-contextmanagerdocumentation .faq-section {\n  margin: 2em 0;\n}\n\nslice-contextmanagerdocumentation .faq-section slice-details {\n  margin-bottom: 1em;\n}\n\n@media (max-width: 768px) {\n  slice-contextmanagerdocumentation {\n    padding: 15px;\n  }\n}\n",
    "size": 22195
  },
  "LoggerDocumentation": {
    "name": "LoggerDocumentation",
    "category": "AppComponents",
    "categoryType": "Visual",
    "js": "class LoggerDocumentation extends HTMLElement {\n  constructor(props) {\n    super();\n    slice.attachTemplate(this);\n    slice.controller.setComponentProps(this, props);\n    this.debuggerProps = [];\n  }\n\n  async init() {\n    this.markdownPath = \"logger.md\";\n    this.markdownContent = \"---\\ntitle: Logger\\nroute: /Documentation/Structural/Logger\\nnavLabel: Logger\\nsection: Getting Started\\ngroup: Diagnostics\\norder: 40\\ndescription: Structured logging and filters for Slice.js.\\ncomponent: LoggerDocumentation\\ntags: [logger, diagnostics, debugging]\\n---\\n\\n# Logger\\n\\n## Overview\\nLogger collects logs and routes them to configured outputs (e.g. console). It supports filtering\\nby level and basic querying over the in-memory log list.\\n\\n## Enable\\n```json title=\\\"sliceConfig.json\\\"\\n{\\n  \\\"logger\\\": {\\n    \\\"enabled\\\": true,\\n    \\\"showLogs\\\": {\\n      \\\"console\\\": { \\\"error\\\": true, \\\"warning\\\": true, \\\"info\\\": true }\\n    }\\n  }\\n}\\n```\\n\\n## API Reference\\n| Method | Signature | Notes |\\n| --- | --- | --- |\\n| `logError` | `(componentSliceId, message, error?)` | Logs error + optional error object |\\n| `logWarning` | `(componentSliceId, message)` | Logs warning |\\n| `logInfo` | `(componentSliceId, message)` | Logs info |\\n| `getLogs` | `()` | Returns all logs |\\n| `clearLogs` | `()` | Clears stored logs |\\n| `getLogsByLogType` | `(type)` | Filter by `error | warning | info` |\\n| `getLogsByComponentCategory` | `(category)` | Filter by component category |\\n| `getLogsByComponent` | `(sliceId)` | Filter by component sliceId |\\n\\n## Usage\\n```javascript title=\\\"Log from a component\\\"\\nclass Navbar extends HTMLElement {\\n  async init() {\\n    slice.logger.logInfo('Navbar', 'Navbar initialized');\\n  }\\n}\\n```\\n\\n```javascript title=\\\"Log with error\\\"\\ntry {\\n  await doWork();\\n} catch (error) {\\n  slice.logger.logError('MyService', 'Work failed', error);\\n}\\n```\\n\\n## Notes\\n- Logging is disabled when `logger.enabled` is false.\\n- Log outputs depend on `logger.showLogs` configuration.\\n\";\n    if (true) {\n      this.setupCopyButton();\n    }\n      {\n         const container = this.querySelector('[data-block-id=\"doc-block-1\"]');\n         if (container) {\n            const code = await slice.build('CodeVisualizer', {\n               value: \"{\\n  \\\"logger\\\": {\\n    \\\"enabled\\\": true,\\n    \\\"showLogs\\\": {\\n      \\\"console\\\": { \\\"error\\\": true, \\\"warning\\\": true, \\\"info\\\": true }\\n    }\\n  }\\n}\",\n               language: \"json\"\n            });\n            if (\"sliceConfig.json\") {\n               const label = document.createElement('div');\n               label.classList.add('code-block-title');\n               label.textContent = \"sliceConfig.json\";\n               container.appendChild(label);\n            }\n            container.appendChild(code);\n         }\n      }\n      {\n         const container = this.querySelector('[data-block-id=\"doc-block-2\"]');\n         if (container) {\n            const lines = [\"| Method | Signature | Notes |\",\"| --- | --- | --- |\",\"| `logError` | `(componentSliceId, message, error?)` | Logs error + optional error object |\",\"| `logWarning` | `(componentSliceId, message)` | Logs warning |\",\"| `logInfo` | `(componentSliceId, message)` | Logs info |\",\"| `getLogs` | `()` | Returns all logs |\",\"| `clearLogs` | `()` | Clears stored logs |\",\"| `getLogsByLogType` | `(type)` | Filter by `error | warning | info` |\",\"| `getLogsByComponentCategory` | `(category)` | Filter by component category |\",\"| `getLogsByComponent` | `(sliceId)` | Filter by component sliceId |\"];\n            const clean = (line) => {\n               let value = line.trim();\n               if (value.startsWith('|')) {\n                  value = value.slice(1);\n               }\n               if (value.endsWith('|')) {\n                  value = value.slice(0, -1);\n               }\n               return value.split('|').map((cell) => cell.trim());\n            };\n\n            const formatCell = (text) => {\n               let output = text\n                  .replace(/&/g, '&amp;')\n                  .replace(/</g, '&lt;')\n                  .replace(/>/g, '&gt;');\n\n               const applyBold = (input) => {\n                  let result = '';\n                  let index = 0;\n                  while (index < input.length) {\n                     const start = input.indexOf('**', index);\n                     if (start === -1) {\n                        result += input.slice(index);\n                        break;\n                     }\n                     const end = input.indexOf('**', start + 2);\n                     if (end === -1) {\n                        result += input.slice(index);\n                        break;\n                     }\n                     result += input.slice(index, start) + '<strong>' + input.slice(start + 2, end) + '</strong>';\n                     index = end + 2;\n                  }\n                  return result;\n               };\n\n               const applyInlineCode = (input) => {\n                  const parts = input.split(String.fromCharCode(96));\n                  if (parts.length === 1) return input;\n                  return parts\n                     .map((part, idx) => (idx % 2 === 1 ? '<code>' + part + '</code>' : part))\n                     .join('');\n               };\n\n               output = applyBold(output);\n               output = applyInlineCode(output);\n               return output;\n            };\n\n            const headers = lines.length > 0 ? clean(lines[0]) : [];\n            const rows = lines.slice(2).map((line) => clean(line).map((cell) => formatCell(cell)));\n            const table = await slice.build('Table', { headers, rows });\n            container.appendChild(table);\n         }\n      }\n      {\n         const container = this.querySelector('[data-block-id=\"doc-block-3\"]');\n         if (container) {\n            const code = await slice.build('CodeVisualizer', {\n               value: \"class Navbar extends HTMLElement {\\n  async init() {\\n    slice.logger.logInfo('Navbar', 'Navbar initialized');\\n  }\\n}\",\n               language: \"javascript\"\n            });\n            if (\"Log from a component\") {\n               const label = document.createElement('div');\n               label.classList.add('code-block-title');\n               label.textContent = \"Log from a component\";\n               container.appendChild(label);\n            }\n            container.appendChild(code);\n         }\n      }\n      {\n         const container = this.querySelector('[data-block-id=\"doc-block-4\"]');\n         if (container) {\n            const code = await slice.build('CodeVisualizer', {\n               value: \"try {\\n  await doWork();\\n} catch (error) {\\n  slice.logger.logError('MyService', 'Work failed', error);\\n}\",\n               language: \"javascript\"\n            });\n            if (\"Log with error\") {\n               const label = document.createElement('div');\n               label.classList.add('code-block-title');\n               label.textContent = \"Log with error\";\n               container.appendChild(label);\n            }\n            container.appendChild(code);\n         }\n      }\n  }\n\n  async update() {\n    // Refresh dynamic content here if needed\n  }\n\n  beforeDestroy() {\n    // Cleanup timers, listeners, or pending work here\n  }\n\n  async setupCopyButton() {\n    const container = this.querySelector('[data-copy-md]');\n    if (!container) return;\n\n    const copyMenu = await slice.build('CopyMarkdownMenu', {\n      markdownPath: this.markdownPath,\n      markdownContent: this.markdownContent,\n      label: '❐'\n    });\n\n    container.appendChild(copyMenu);\n  }\n\n  async copyMarkdown() {}\n}\n\nwindow.LoggerDocumentation = LoggerDocumentation;\ncustomElements.define('slice-loggerdocumentation', LoggerDocumentation);\n\nreturn LoggerDocumentation;",
    "externalDependencies": {},
    "componentDependencies": [
      "CodeVisualizer",
      "Table",
      "CopyMarkdownMenu"
    ],
    "html": "<div class=\"documentation-content loggerdocumentation\">\n\n<div class=\"doc-title-bar\">\n  <h1 id=\"logger\">\n    <span class=\"doc-title-text\">Logger</span>\n    <span class=\"copy-md-slot\" data-copy-md></span>\n  </h1>\n</div>\n<h2 id=\"overview\">Overview</h2>\n<p>Logger collects logs and routes them to configured outputs (e.g. console). It supports filtering by level and basic querying over the in-memory log list.</p>\n<h2 id=\"enable\">Enable</h2>\n<div class=\"code-block\" data-block-id=\"doc-block-1\"></div>\n<h2 id=\"api-reference\">API Reference</h2>\n<div class=\"table-block\" data-block-id=\"doc-block-2\"></div>\n<h2 id=\"usage\">Usage</h2>\n<div class=\"code-block\" data-block-id=\"doc-block-3\"></div>\n<div class=\"code-block\" data-block-id=\"doc-block-4\"></div>\n<h2 id=\"notes\">Notes</h2>\n<ul><li>Logging is disabled when <code>logger.enabled</code> is false.</li><li>Log outputs depend on <code>logger.showLogs</code> configuration.</li></ul>\n</div>\n",
    "css": "/* Generated documentation styles */\n/* Keep shared styles in src/Styles/DocumentationBase.css */\n",
    "size": 8773
  },
  "TheBuildMethod": {
    "name": "TheBuildMethod",
    "category": "AppComponents",
    "categoryType": "Visual",
    "js": "class TheBuildMethod extends HTMLElement {\n  constructor(props) {\n    super();\n    slice.attachTemplate(this);\n    slice.controller.setComponentProps(this, props);\n    this.debuggerProps = [];\n  }\n\n  async init() {\n    this.markdownPath = \"getting-started/build-method.md\";\n    this.markdownContent = \"---\\ntitle: The build method\\nroute: /Documentation/The-build-method\\nnavLabel: The build method\\nsection: Getting Started\\ngroup: Components\\norder: 31\\ndescription: Use slice.build to create components.\\ncomponent: TheBuildMethod\\ntags: [build, components]\\n---\\n\\n# The build method\\n\\n## Overview\\n`slice.build(componentName, props)` creates a component instance, applies Static Props, runs\\n`init()`, and registers the component with the controller. It returns a ready-to-append component\\ninstance.\\n\\nThis is the standard way to create Visual, App, and Service components in Slice.js.\\n\\n## API\\n| Parameter | Type | Required | Notes |\\n| --- | --- | --- | --- |\\n| `componentName` | `string` | yes | Must exist in `components.js`. |\\n| `props` | `object` | no | Public props for the component. |\\n\\n| Returns | Type | Notes |\\n| --- | --- | --- |\\n| component instance | `HTMLElement | Object | null` | Returns `null` on error. |\\n\\n## Lifecycle Steps\\n1. Validate component name.\\n2. Load template, class, and CSS (visual components only).\\n3. Instantiate component and apply props.\\n4. Call `init()` if present.\\n5. Register component in the controller and component tree.\\n\\n## Basic Usage\\n```javascript title=\\\"Basic build\\\"\\nconst myButton = await slice.build('Button', {\\n  value: 'Click me'\\n});\\n\\ndocument.querySelector('#container').appendChild(myButton);\\n```\\n\\n## Props and Defaults\\n```javascript title=\\\"Props are applied immediately\\\"\\nconst card = await slice.build('Card', {\\n  title: 'My Card',\\n  text: 'Card content',\\n  icon: { name: 'star', iconStyle: 'filled' }\\n});\\n\\n// Card now has this.title, this.text, this.icon\\n```\\n\\n## id and sliceId\\n`id` and `sliceId` are handled specially. They are assigned to the instance and then removed\\nfrom the props object before Static Props are applied.\\n\\n```javascript title=\\\"Use sliceId for lookup\\\"\\nconst navbar = await slice.build('Navbar', {\\n  sliceId: 'main-navbar',\\n  logo: { src: '/logo.png', path: '/' },\\n  items: [{ text: 'Home', path: '/' }]\\n});\\n\\nconst sameNavbar = slice.controller.getComponent('main-navbar');\\n```\\n\\n## Nested Components\\n```javascript title=\\\"Build children and compose\\\"\\nconst grid = await slice.build('Grid', { columns: 3, rows: 1 });\\nconst card1 = await slice.build('Card', { title: 'Card 1' });\\nconst card2 = await slice.build('Card', { title: 'Card 2' });\\nconst card3 = await slice.build('Card', { title: 'Card 3' });\\n\\nawait grid.setItem(card1);\\nawait grid.setItem(card2);\\nawait grid.setItem(card3);\\n\\nthis.appendChild(grid);\\n```\\n\\n## Error Cases\\n- Missing or non-string component name\\n- Component not listed in `components.js`\\n- Structural components cannot be built\\n\\n## Best Practices\\n:::tip\\nAlways await `slice.build()` to ensure templates, CSS, and `init()` are finished.\\n:::\\n\\n:::tip\\nUse `sliceId` only when you need to retrieve a component later.\\n:::\\n\\n## Gotchas\\n:::warning\\nBuilding a component can return `null` if the component is missing or fails to load.\\n:::\\n\\n:::warning\\nStructural components are created by the framework and cannot be built directly.\\n:::\\n\";\n    if (true) {\n      this.setupCopyButton();\n    }\n      {\n         const container = this.querySelector('[data-block-id=\"doc-block-1\"]');\n         if (container) {\n            const lines = [\"| Parameter | Type | Required | Notes |\",\"| --- | --- | --- | --- |\",\"| `componentName` | `string` | yes | Must exist in `components.js`. |\",\"| `props` | `object` | no | Public props for the component. |\"];\n            const clean = (line) => {\n               let value = line.trim();\n               if (value.startsWith('|')) {\n                  value = value.slice(1);\n               }\n               if (value.endsWith('|')) {\n                  value = value.slice(0, -1);\n               }\n               return value.split('|').map((cell) => cell.trim());\n            };\n\n            const formatCell = (text) => {\n               let output = text\n                  .replace(/&/g, '&amp;')\n                  .replace(/</g, '&lt;')\n                  .replace(/>/g, '&gt;');\n\n               const applyBold = (input) => {\n                  let result = '';\n                  let index = 0;\n                  while (index < input.length) {\n                     const start = input.indexOf('**', index);\n                     if (start === -1) {\n                        result += input.slice(index);\n                        break;\n                     }\n                     const end = input.indexOf('**', start + 2);\n                     if (end === -1) {\n                        result += input.slice(index);\n                        break;\n                     }\n                     result += input.slice(index, start) + '<strong>' + input.slice(start + 2, end) + '</strong>';\n                     index = end + 2;\n                  }\n                  return result;\n               };\n\n               const applyInlineCode = (input) => {\n                  const parts = input.split(String.fromCharCode(96));\n                  if (parts.length === 1) return input;\n                  return parts\n                     .map((part, idx) => (idx % 2 === 1 ? '<code>' + part + '</code>' : part))\n                     .join('');\n               };\n\n               output = applyBold(output);\n               output = applyInlineCode(output);\n               return output;\n            };\n\n            const headers = lines.length > 0 ? clean(lines[0]) : [];\n            const rows = lines.slice(2).map((line) => clean(line).map((cell) => formatCell(cell)));\n            const table = await slice.build('Table', { headers, rows });\n            container.appendChild(table);\n         }\n      }\n      {\n         const container = this.querySelector('[data-block-id=\"doc-block-2\"]');\n         if (container) {\n            const lines = [\"| Returns | Type | Notes |\",\"| --- | --- | --- |\",\"| component instance | `HTMLElement | Object | null` | Returns `null` on error. |\"];\n            const clean = (line) => {\n               let value = line.trim();\n               if (value.startsWith('|')) {\n                  value = value.slice(1);\n               }\n               if (value.endsWith('|')) {\n                  value = value.slice(0, -1);\n               }\n               return value.split('|').map((cell) => cell.trim());\n            };\n\n            const formatCell = (text) => {\n               let output = text\n                  .replace(/&/g, '&amp;')\n                  .replace(/</g, '&lt;')\n                  .replace(/>/g, '&gt;');\n\n               const applyBold = (input) => {\n                  let result = '';\n                  let index = 0;\n                  while (index < input.length) {\n                     const start = input.indexOf('**', index);\n                     if (start === -1) {\n                        result += input.slice(index);\n                        break;\n                     }\n                     const end = input.indexOf('**', start + 2);\n                     if (end === -1) {\n                        result += input.slice(index);\n                        break;\n                     }\n                     result += input.slice(index, start) + '<strong>' + input.slice(start + 2, end) + '</strong>';\n                     index = end + 2;\n                  }\n                  return result;\n               };\n\n               const applyInlineCode = (input) => {\n                  const parts = input.split(String.fromCharCode(96));\n                  if (parts.length === 1) return input;\n                  return parts\n                     .map((part, idx) => (idx % 2 === 1 ? '<code>' + part + '</code>' : part))\n                     .join('');\n               };\n\n               output = applyBold(output);\n               output = applyInlineCode(output);\n               return output;\n            };\n\n            const headers = lines.length > 0 ? clean(lines[0]) : [];\n            const rows = lines.slice(2).map((line) => clean(line).map((cell) => formatCell(cell)));\n            const table = await slice.build('Table', { headers, rows });\n            container.appendChild(table);\n         }\n      }\n      {\n         const container = this.querySelector('[data-block-id=\"doc-block-3\"]');\n         if (container) {\n            const code = await slice.build('CodeVisualizer', {\n               value: \"const myButton = await slice.build('Button', {\\n  value: 'Click me'\\n});\\n\\ndocument.querySelector('#container').appendChild(myButton);\",\n               language: \"javascript\"\n            });\n            if (\"Basic build\") {\n               const label = document.createElement('div');\n               label.classList.add('code-block-title');\n               label.textContent = \"Basic build\";\n               container.appendChild(label);\n            }\n            container.appendChild(code);\n         }\n      }\n      {\n         const container = this.querySelector('[data-block-id=\"doc-block-4\"]');\n         if (container) {\n            const code = await slice.build('CodeVisualizer', {\n               value: \"const card = await slice.build('Card', {\\n  title: 'My Card',\\n  text: 'Card content',\\n  icon: { name: 'star', iconStyle: 'filled' }\\n});\\n\\n// Card now has this.title, this.text, this.icon\",\n               language: \"javascript\"\n            });\n            if (\"Props are applied immediately\") {\n               const label = document.createElement('div');\n               label.classList.add('code-block-title');\n               label.textContent = \"Props are applied immediately\";\n               container.appendChild(label);\n            }\n            container.appendChild(code);\n         }\n      }\n      {\n         const container = this.querySelector('[data-block-id=\"doc-block-5\"]');\n         if (container) {\n            const code = await slice.build('CodeVisualizer', {\n               value: \"const navbar = await slice.build('Navbar', {\\n  sliceId: 'main-navbar',\\n  logo: { src: '/logo.png', path: '/' },\\n  items: [{ text: 'Home', path: '/' }]\\n});\\n\\nconst sameNavbar = slice.controller.getComponent('main-navbar');\",\n               language: \"javascript\"\n            });\n            if (\"Use sliceId for lookup\") {\n               const label = document.createElement('div');\n               label.classList.add('code-block-title');\n               label.textContent = \"Use sliceId for lookup\";\n               container.appendChild(label);\n            }\n            container.appendChild(code);\n         }\n      }\n      {\n         const container = this.querySelector('[data-block-id=\"doc-block-6\"]');\n         if (container) {\n            const code = await slice.build('CodeVisualizer', {\n               value: \"const grid = await slice.build('Grid', { columns: 3, rows: 1 });\\nconst card1 = await slice.build('Card', { title: 'Card 1' });\\nconst card2 = await slice.build('Card', { title: 'Card 2' });\\nconst card3 = await slice.build('Card', { title: 'Card 3' });\\n\\nawait grid.setItem(card1);\\nawait grid.setItem(card2);\\nawait grid.setItem(card3);\\n\\nthis.appendChild(grid);\",\n               language: \"javascript\"\n            });\n            if (\"Build children and compose\") {\n               const label = document.createElement('div');\n               label.classList.add('code-block-title');\n               label.textContent = \"Build children and compose\";\n               container.appendChild(label);\n            }\n            container.appendChild(code);\n         }\n      }\n  }\n\n  async update() {\n    // Refresh dynamic content here if needed\n  }\n\n  beforeDestroy() {\n    // Cleanup timers, listeners, or pending work here\n  }\n\n  async setupCopyButton() {\n    const container = this.querySelector('[data-copy-md]');\n    if (!container) return;\n\n    const copyMenu = await slice.build('CopyMarkdownMenu', {\n      markdownPath: this.markdownPath,\n      markdownContent: this.markdownContent,\n      label: '❐'\n    });\n\n    container.appendChild(copyMenu);\n  }\n\n  async copyMarkdown() {}\n}\n\nwindow.TheBuildMethod = TheBuildMethod;\ncustomElements.define('slice-thebuildmethod', TheBuildMethod);\n\nreturn TheBuildMethod;",
    "externalDependencies": {},
    "componentDependencies": [
      "Table",
      "CodeVisualizer",
      "CopyMarkdownMenu"
    ],
    "html": "<div class=\"documentation-content thebuildmethod\">\n\n<div class=\"doc-title-bar\">\n  <h1 id=\"the-build-method\">\n    <span class=\"doc-title-text\">The build method</span>\n    <span class=\"copy-md-slot\" data-copy-md></span>\n  </h1>\n</div>\n<h2 id=\"overview\">Overview</h2>\n<p><code>slice.build(componentName, props)</code> creates a component instance, applies Static Props, runs <code>init()</code>, and registers the component with the controller. It returns a ready-to-append component instance.</p>\n<p>This is the standard way to create Visual, App, and Service components in Slice.js.</p>\n<h2 id=\"api\">API</h2>\n<div class=\"table-block\" data-block-id=\"doc-block-1\"></div>\n<div class=\"table-block\" data-block-id=\"doc-block-2\"></div>\n<h2 id=\"lifecycle-steps\">Lifecycle Steps</h2>\n<ol><li>Validate component name.</li><li>Load template, class, and CSS (visual components only).</li><li>Instantiate component and apply props.</li><li>Call <code>init()</code> if present.</li><li>Register component in the controller and component tree.</li></ol>\n<h2 id=\"basic-usage\">Basic Usage</h2>\n<div class=\"code-block\" data-block-id=\"doc-block-3\"></div>\n<h2 id=\"props-and-defaults\">Props and Defaults</h2>\n<div class=\"code-block\" data-block-id=\"doc-block-4\"></div>\n<h2 id=\"id-and-sliceid\">id and sliceId</h2>\n<p><code>id</code> and <code>sliceId</code> are handled specially. They are assigned to the instance and then removed from the props object before Static Props are applied.</p>\n<div class=\"code-block\" data-block-id=\"doc-block-5\"></div>\n<h2 id=\"nested-components\">Nested Components</h2>\n<div class=\"code-block\" data-block-id=\"doc-block-6\"></div>\n<h2 id=\"error-cases\">Error Cases</h2>\n<ul><li>Missing or non-string component name</li><li>Component not listed in <code>components.js</code></li><li>Structural components cannot be built</li></ul>\n<h2 id=\"best-practices\">Best Practices</h2>\n<div class=\"callout callout-tip\">Always await <code>slice.build()</code> to ensure templates, CSS, and <code>init()</code> are finished.</div>\n<div class=\"callout callout-tip\">Use <code>sliceId</code> only when you need to retrieve a component later.</div>\n<h2 id=\"gotchas\">Gotchas</h2>\n<div class=\"callout callout-warning\">Building a component can return <code>null</code> if the component is missing or fails to load.</div>\n<div class=\"callout callout-warning\">Structural components are created by the framework and cannot be built directly.</div>\n</div>\n",
    "css": "/* TheBuildMethod Component Styles */\r\n\r\nslice-thebuildmethod {\n  color: var(--font-primary-color);\n  display: block;\n  max-width: 1200px;\n  margin: 0 auto;\n  padding: 20px;\n}\n\r\nslice-thebuildmethod h1,\nslice-thebuildmethod h2,\nslice-thebuildmethod h3 {\n  margin-top: 1.5em;\n  margin-bottom: 0.5em;\n}\n\nslice-thebuildmethod h1 {\n  text-align: center;\n  border-bottom: 3px solid var(--primary-color);\n  padding-bottom: 12px;\n}\n\nslice-thebuildmethod .doc-title-bar {\n  display: flex;\n  align-items: center;\n  gap: 12px;\n  margin-bottom: 16px;\n  flex-wrap: nowrap;\n  justify-content: center;\n}\n\nslice-thebuildmethod .doc-title-bar h1 {\n  margin: 0;\n  border-bottom: none;\n  padding-bottom: 0;\n  text-align: center;\n  display: inline-flex;\n  align-items: center;\n  gap: 12px;\n  justify-content: center;\n  width: 100%;\n}\n\nslice-thebuildmethod .doc-title-text {\n  text-align: center;\n}\n\nslice-thebuildmethod .copy-md-slot {\n  display: inline-flex;\n  align-items: center;\n  flex-shrink: 0;\n  position: relative;\n}\n\r\nslice-thebuildmethod h2 {\n  margin-top: 30px;\n  border-bottom: 1px solid var(--primary-color-shade);\n  padding-bottom: 8px;\n}\n\r\nslice-thebuildmethod p {\n  line-height: 1.6;\n  margin: 1em 0;\n}\n\nslice-thebuildmethod ul,\nslice-thebuildmethod ol {\n  margin: 1em 0;\n  padding-left: 2em;\n}\n\nslice-thebuildmethod li {\n  margin-bottom: 0.5em;\n}\n\nslice-thebuildmethod code {\n  font-family: monospace;\n  background-color: var(--secondary-background-color);\n  padding: 0.2em 0.4em;\n  border-radius: 3px;\n  font-size: 0.9em;\n}\n\r\nslice-thebuildmethod .syntax-example,\nslice-thebuildmethod .basic-example,\nslice-thebuildmethod .props-example,\nslice-thebuildmethod .nested-example,\nslice-thebuildmethod .sliceid-example,\nslice-thebuildmethod .error-example,\nslice-thebuildmethod .patterns-example {\n  margin: 1.5em 0;\n}\n\nslice-thebuildmethod strong {\n  color: var(--primary-color);\n}\n\r\n/* Parameter boxes styling */\r\nslice-thebuildmethod .parameter-box {\n  background-color: var(--secondary-background-color);\n  border-left: 4px solid var(--primary-color);\n  padding: 1.5em;\n  margin: 1.5em 0;\n  border-radius: 4px;\n}\n\nslice-thebuildmethod .parameter-header {\n  display: flex;\n  align-items: center;\n  gap: 1em;\n  margin-bottom: 0.8em;\n}\n\nslice-thebuildmethod .parameter-name {\n  font-size: 1.2em;\n  font-weight: bold;\n  background-color: var(--primary-color);\n  color: var(--primary-color-contrast);\n  padding: 0.3em 0.6em;\n  border-radius: 4px;\n}\n\nslice-thebuildmethod .parameter-type {\n  font-size: 0.9em;\n  color: var(--font-secondary-color);\n  font-style: italic;\n}\n\nslice-thebuildmethod .parameter-description {\n  margin: 0;\n  font-size: 1em;\n  line-height: 1.5;\n}\n\r\n/* Lifecycle list */\r\nslice-thebuildmethod .lifecycle-list {\n  background-color: var(--secondary-background-color);\n  padding: 1.5em 2em;\n  border-radius: 4px;\n  margin: 1.5em 0;\n}\n\nslice-thebuildmethod .lifecycle-list li {\n  padding: 0.5em 0;\n  border-bottom: 1px solid var(--primary-color-shade);\n}\n\nslice-thebuildmethod .lifecycle-list li:last-child {\n  border-bottom: none;\n}\n\r\n/* FAQ section */\r\nslice-thebuildmethod .faq-section {\n  margin: 2em 0;\n}\n\nslice-thebuildmethod .faq-section slice-details {\n  margin-bottom: 1em;\n}\n\n@media (max-width: 768px) {\n  slice-thebuildmethod {\n    padding: 15px;\n  }\n}\n",
    "size": 18069
  },
  "StaticPropsDocumentation": {
    "name": "StaticPropsDocumentation",
    "category": "AppComponents",
    "categoryType": "Visual",
    "js": "class StaticPropsDocumentation extends HTMLElement {\n  constructor(props) {\n    super();\n    slice.attachTemplate(this);\n    slice.controller.setComponentProps(this, props);\n    this.debuggerProps = [];\n  }\n\n  async init() {\n    this.markdownPath = \"getting-started/static-props.md\";\n    this.markdownContent = \"---\\ntitle: Static Props\\nroute: /Documentation/Static-Props\\nnavLabel: Static Props\\nsection: Getting Started\\ngroup: Components\\norder: 30\\ndescription: Define and validate component props in Slice.js.\\ncomponent: StaticPropsDocumentation\\ntags: [props, static, validation]\\n---\\n\\n# Static Props\\n\\n## Overview\\nStatic Props define a component's public API. They provide defaults, development-only validation,\\nand consistent prop behavior across Slice.js. They also power the debugger by describing which\\nprops are available and used.\\n\\n## Static Props Schema\\n| Field | Type | Required | Notes |\\n| --- | --- | --- | --- |\\n| `type` | `string` | no | Informational only (debugger). |\\n| `default` | `any` | no | Applied when prop is not provided. |\\n| `required` | `boolean` | no | Logs error when missing in development. |\\n\\n## How Props Are Applied\\nWhen a component is built:\\n\\n- Defaults are applied for missing props.\\n- Unknown props produce warnings in development.\\n- Missing required props produce errors in development.\\n- Props are assigned to the instance (`component[prop]`) and tracked internally.\\n\\n```javascript title=\\\"Props are processed by the Controller\\\"\\nclass Button extends HTMLElement {\\n  static props = {\\n    value: { type: 'string', default: 'Button' },\\n    onClickCallback: { type: 'function', default: null }\\n  };\\n\\n  constructor(props) {\\n    super();\\n    slice.attachTemplate(this);\\n    slice.controller.setComponentProps(this, props);\\n\\n    // Props are now available\\n    console.log(this.value);\\n    console.log(this.onClickCallback);\\n  }\\n}\\n```\\n\\n## Defaults and Required Fields\\n```javascript title=\\\"Defaults and required props\\\"\\nstatic props = {\\n  title: { type: 'string', default: 'Untitled', required: false },\\n  id: { type: 'string', required: true }\\n};\\n```\\n\\n## Validation (Development Only)\\nSlice warns about unknown props and errors on missing required props in development mode.\\nIn production, validation is skipped for performance.\\n\\n## Usage Patterns\\n```javascript title=\\\"Building with props\\\"\\nconst card = await slice.build('Card', {\\n  title: 'My Card',\\n  text: 'Card content',\\n  icon: { name: 'star', iconStyle: 'filled' }\\n});\\n```\\n\\n```javascript title=\\\"Props with arrays and objects\\\"\\nconst grid = await slice.build('Grid', {\\n  columns: 3,\\n  rows: 2,\\n  gap: '16px',\\n  style: { border: '1px solid #ccc' }\\n});\\n```\\n\\n```javascript title=\\\"Function props\\\"\\nconst button = await slice.build('Button', {\\n  value: 'Save',\\n  onClickCallback: () => this.save()\\n});\\n```\\n\\n## Best Practices\\n:::tip\\nDefine only public props in `static props` and use internal fields for private state.\\n:::\\n\\n:::tip\\nUse defaults to keep components predictable and reduce boilerplate.\\n:::\\n\\n## Gotchas\\n:::warning\\nStatic Props validation runs only in development; validate critical data yourself.\\n:::\\n\";\n    if (true) {\n      this.setupCopyButton();\n    }\n      {\n         const container = this.querySelector('[data-block-id=\"doc-block-1\"]');\n         if (container) {\n            const lines = [\"| Field | Type | Required | Notes |\",\"| --- | --- | --- | --- |\",\"| `type` | `string` | no | Informational only (debugger). |\",\"| `default` | `any` | no | Applied when prop is not provided. |\",\"| `required` | `boolean` | no | Logs error when missing in development. |\"];\n            const clean = (line) => {\n               let value = line.trim();\n               if (value.startsWith('|')) {\n                  value = value.slice(1);\n               }\n               if (value.endsWith('|')) {\n                  value = value.slice(0, -1);\n               }\n               return value.split('|').map((cell) => cell.trim());\n            };\n\n            const formatCell = (text) => {\n               let output = text\n                  .replace(/&/g, '&amp;')\n                  .replace(/</g, '&lt;')\n                  .replace(/>/g, '&gt;');\n\n               const applyBold = (input) => {\n                  let result = '';\n                  let index = 0;\n                  while (index < input.length) {\n                     const start = input.indexOf('**', index);\n                     if (start === -1) {\n                        result += input.slice(index);\n                        break;\n                     }\n                     const end = input.indexOf('**', start + 2);\n                     if (end === -1) {\n                        result += input.slice(index);\n                        break;\n                     }\n                     result += input.slice(index, start) + '<strong>' + input.slice(start + 2, end) + '</strong>';\n                     index = end + 2;\n                  }\n                  return result;\n               };\n\n               const applyInlineCode = (input) => {\n                  const parts = input.split(String.fromCharCode(96));\n                  if (parts.length === 1) return input;\n                  return parts\n                     .map((part, idx) => (idx % 2 === 1 ? '<code>' + part + '</code>' : part))\n                     .join('');\n               };\n\n               output = applyBold(output);\n               output = applyInlineCode(output);\n               return output;\n            };\n\n            const headers = lines.length > 0 ? clean(lines[0]) : [];\n            const rows = lines.slice(2).map((line) => clean(line).map((cell) => formatCell(cell)));\n            const table = await slice.build('Table', { headers, rows });\n            container.appendChild(table);\n         }\n      }\n      {\n         const container = this.querySelector('[data-block-id=\"doc-block-2\"]');\n         if (container) {\n            const code = await slice.build('CodeVisualizer', {\n               value: \"class Button extends HTMLElement {\\n  static props = {\\n    value: { type: 'string', default: 'Button' },\\n    onClickCallback: { type: 'function', default: null }\\n  };\\n\\n  constructor(props) {\\n    super();\\n    slice.attachTemplate(this);\\n    slice.controller.setComponentProps(this, props);\\n\\n    // Props are now available\\n    console.log(this.value);\\n    console.log(this.onClickCallback);\\n  }\\n}\",\n               language: \"javascript\"\n            });\n            if (\"Props are processed by the Controller\") {\n               const label = document.createElement('div');\n               label.classList.add('code-block-title');\n               label.textContent = \"Props are processed by the Controller\";\n               container.appendChild(label);\n            }\n            container.appendChild(code);\n         }\n      }\n      {\n         const container = this.querySelector('[data-block-id=\"doc-block-3\"]');\n         if (container) {\n            const code = await slice.build('CodeVisualizer', {\n               value: \"static props = {\\n  title: { type: 'string', default: 'Untitled', required: false },\\n  id: { type: 'string', required: true }\\n};\",\n               language: \"javascript\"\n            });\n            if (\"Defaults and required props\") {\n               const label = document.createElement('div');\n               label.classList.add('code-block-title');\n               label.textContent = \"Defaults and required props\";\n               container.appendChild(label);\n            }\n            container.appendChild(code);\n         }\n      }\n      {\n         const container = this.querySelector('[data-block-id=\"doc-block-4\"]');\n         if (container) {\n            const code = await slice.build('CodeVisualizer', {\n               value: \"const card = await slice.build('Card', {\\n  title: 'My Card',\\n  text: 'Card content',\\n  icon: { name: 'star', iconStyle: 'filled' }\\n});\",\n               language: \"javascript\"\n            });\n            if (\"Building with props\") {\n               const label = document.createElement('div');\n               label.classList.add('code-block-title');\n               label.textContent = \"Building with props\";\n               container.appendChild(label);\n            }\n            container.appendChild(code);\n         }\n      }\n      {\n         const container = this.querySelector('[data-block-id=\"doc-block-5\"]');\n         if (container) {\n            const code = await slice.build('CodeVisualizer', {\n               value: \"const grid = await slice.build('Grid', {\\n  columns: 3,\\n  rows: 2,\\n  gap: '16px',\\n  style: { border: '1px solid #ccc' }\\n});\",\n               language: \"javascript\"\n            });\n            if (\"Props with arrays and objects\") {\n               const label = document.createElement('div');\n               label.classList.add('code-block-title');\n               label.textContent = \"Props with arrays and objects\";\n               container.appendChild(label);\n            }\n            container.appendChild(code);\n         }\n      }\n      {\n         const container = this.querySelector('[data-block-id=\"doc-block-6\"]');\n         if (container) {\n            const code = await slice.build('CodeVisualizer', {\n               value: \"const button = await slice.build('Button', {\\n  value: 'Save',\\n  onClickCallback: () => this.save()\\n});\",\n               language: \"javascript\"\n            });\n            if (\"Function props\") {\n               const label = document.createElement('div');\n               label.classList.add('code-block-title');\n               label.textContent = \"Function props\";\n               container.appendChild(label);\n            }\n            container.appendChild(code);\n         }\n      }\n  }\n\n  async update() {\n    // Refresh dynamic content here if needed\n  }\n\n  beforeDestroy() {\n    // Cleanup timers, listeners, or pending work here\n  }\n\n  async setupCopyButton() {\n    const container = this.querySelector('[data-copy-md]');\n    if (!container) return;\n\n    const copyMenu = await slice.build('CopyMarkdownMenu', {\n      markdownPath: this.markdownPath,\n      markdownContent: this.markdownContent,\n      label: '❐'\n    });\n\n    container.appendChild(copyMenu);\n  }\n\n  async copyMarkdown() {}\n}\n\nwindow.StaticPropsDocumentation = StaticPropsDocumentation;\ncustomElements.define('slice-staticpropsdocumentation', StaticPropsDocumentation);\n\nreturn StaticPropsDocumentation;",
    "externalDependencies": {},
    "componentDependencies": [
      "Table",
      "CodeVisualizer",
      "CopyMarkdownMenu"
    ],
    "html": "<div class=\"documentation-content staticpropsdocumentation\">\n\n<div class=\"doc-title-bar\">\n  <h1 id=\"static-props\">\n    <span class=\"doc-title-text\">Static Props</span>\n    <span class=\"copy-md-slot\" data-copy-md></span>\n  </h1>\n</div>\n<h2 id=\"overview\">Overview</h2>\n<p>Static Props define a component's public API. They provide defaults, development-only validation, and consistent prop behavior across Slice.js. They also power the debugger by describing which props are available and used.</p>\n<h2 id=\"static-props-schema\">Static Props Schema</h2>\n<div class=\"table-block\" data-block-id=\"doc-block-1\"></div>\n<h2 id=\"how-props-are-applied\">How Props Are Applied</h2>\n<p>When a component is built:</p>\n<ul><li>Defaults are applied for missing props.</li><li>Unknown props produce warnings in development.</li><li>Missing required props produce errors in development.</li><li>Props are assigned to the instance (<code>component[prop]</code>) and tracked internally.</li></ul>\n<div class=\"code-block\" data-block-id=\"doc-block-2\"></div>\n<h2 id=\"defaults-and-required-fields\">Defaults and Required Fields</h2>\n<div class=\"code-block\" data-block-id=\"doc-block-3\"></div>\n<h2 id=\"validation-development-only\">Validation (Development Only)</h2>\n<p>Slice warns about unknown props and errors on missing required props in development mode. In production, validation is skipped for performance.</p>\n<h2 id=\"usage-patterns\">Usage Patterns</h2>\n<div class=\"code-block\" data-block-id=\"doc-block-4\"></div>\n<div class=\"code-block\" data-block-id=\"doc-block-5\"></div>\n<div class=\"code-block\" data-block-id=\"doc-block-6\"></div>\n<h2 id=\"best-practices\">Best Practices</h2>\n<div class=\"callout callout-tip\">Define only public props in <code>static props</code> and use internal fields for private state.</div>\n<div class=\"callout callout-tip\">Use defaults to keep components predictable and reduce boilerplate.</div>\n<h2 id=\"gotchas\">Gotchas</h2>\n<div class=\"callout callout-warning\">Static Props validation runs only in development; validate critical data yourself.</div>\n</div>\n",
    "css": "/* Static Props Documentation Component Styles */\r\nslice-staticpropsdocumentation {\r\n    display: block;\r\n    max-width: 1200px;\r\n    margin: 0 auto;\r\n    padding: 20px;\r\n    font-family: var(--font-family);\r\n    line-height: 1.6;\r\n    color: var(--font-primary-color);\r\n}\r\n\r\nslice-staticpropsdocumentation h1 {\r\n    color: var(--font-primary-color);\r\n    font-size: 2.5em;\r\n    margin-bottom: 20px;\r\n    text-align: center;\r\n    border-bottom: 3px solid var(--primary-color);\r\n    padding-bottom: 15px;\r\n}\r\n\r\nslice-staticpropsdocumentation h2 {\r\n    color: var(--font-secondary-color);\r\n    font-size: 1.8em;\r\n    margin: 30px 0 20px 0;\r\n    padding: 10px 0;\r\n    border-left: 4px solid var(--primary-color);\r\n    padding-left: 15px;\r\n}\r\n\r\nslice-staticpropsdocumentation h3 {\r\n    color: var(--font-primary-color);\r\n    font-size: 1.4em;\r\n    margin: 25px 0 15px 0;\r\n}\r\n\r\nslice-staticpropsdocumentation p {\r\n    margin-bottom: 15px;\r\n    font-size: 1.1em;\r\n}\r\n\r\nslice-staticpropsdocumentation code {\r\n    font-family: monospace;\r\n    background-color: var(--secondary-background-color);\r\n    padding: 2px 6px;\r\n    border-radius: var(--border-radius-slice);\r\n    color: var(--danger-color);\r\n    font-size: 0.9em;\r\n}\r\n\r\n/* Introduction Section */\r\nslice-staticpropsdocumentation .intro-section {\r\n    margin: 30px 0;\r\n    text-align: center;\r\n}\r\n\r\n/* Content Sections */\r\nslice-staticpropsdocumentation .content-sections {\r\n    margin: 40px 0;\r\n}\r\n\r\nslice-staticpropsdocumentation .content-sections > div {\r\n    margin: 30px 0;\r\n    padding: 20px 0;\r\n}\r\n\r\n/* Summary Section */\r\nslice-staticpropsdocumentation .summary {\r\n    margin: 40px 0;\r\n    padding: 30px 0;\r\n}\r\n\r\nslice-staticpropsdocumentation .summary h2 {\r\n    color: var(--font-primary-color);\r\n    border-left: 4px solid var(--primary-color);\r\n    margin-top: 0;\r\n}\r\n\r\nslice-staticpropsdocumentation .summary h3 {\r\n    color: var(--font-secondary-color);\r\n    margin-top: 25px;\r\n}\r\n\r\n/* Key Points */\r\nslice-staticpropsdocumentation .key-points {\r\n    margin: 25px 0;\r\n    padding: 20px 0;\r\n    border-left: 3px solid var(--primary-color);\r\n    padding-left: 20px;\r\n}\r\n\r\nslice-staticpropsdocumentation .key-points ul {\r\n    margin: 15px 0;\r\n    padding-left: 20px;\r\n}\r\n\r\nslice-staticpropsdocumentation .key-points li {\r\n    margin-bottom: 10px;\r\n    line-height: 1.5;\r\n}\r\n\r\nslice-staticpropsdocumentation .key-points strong {\r\n    color: var(--primary-color);\r\n}\r\n\r\n/* Next Steps */\r\nslice-staticpropsdocumentation .next-steps {\r\n    margin: 25px 0;\r\n    padding: 20px 0;\r\n    border-left: 3px solid var(--success-color);\r\n    padding-left: 20px;\r\n}\r\n\r\n/* Card Component Styling */\r\nslice-staticpropsdocumentation .card {\r\n    margin: 20px 0;\r\n}\r\n\r\n/* Details Component Styling */\r\nslice-staticpropsdocumentation .details {\r\n    margin: 20px 0;\r\n}\r\n\r\n/* Code Visualizer Styling */\r\nslice-staticpropsdocumentation .codevisualizer_container {\r\n    margin: 15px 0;\r\n}\r\n\r\n/* Responsive Design */\r\n@media (max-width: 768px) {\r\n    slice-staticpropsdocumentation {\r\n        padding: 15px;\r\n    }\r\n    \r\n    slice-staticpropsdocumentation h1 {\r\n        font-size: 2em;\r\n    }\r\n    \r\n    slice-staticpropsdocumentation h2 {\r\n        font-size: 1.5em;\r\n    }\r\n    \r\n    slice-staticpropsdocumentation .content-sections > div {\r\n        padding: 15px 0;\r\n        margin: 20px 0;\r\n    }\r\n    \r\n    slice-staticpropsdocumentation .summary {\r\n        padding: 20px 0;\r\n    }\r\n}\r\n\r\n/* Dark theme support is handled by CSS variables */\r\n\r\n/* Print Styles */\r\n@media print {\r\n    slice-staticpropsdocumentation {\r\n        max-width: none;\r\n        padding: 0;\r\n    }\r\n    \r\n    slice-staticpropsdocumentation .content-sections > div {\r\n        break-inside: avoid;\r\n        margin: 15px 0;\r\n        padding: 15px;\r\n        border: 1px solid var(--primary-color-shade);\r\n        background: var(--primary-background-color);\r\n    }\r\n    \r\n    slice-staticpropsdocumentation .summary {\r\n        background: var(--primary-background-color);\r\n        border: 2px solid var(--primary-color);\r\n    }\r\n}\r\n",
    "size": 16516
  },
  "LifeCycleMethods": {
    "name": "LifeCycleMethods",
    "category": "AppComponents",
    "categoryType": "Visual",
    "js": "class LifeCycleMethods extends HTMLElement {\n  constructor(props) {\n    super();\n    slice.attachTemplate(this);\n    slice.controller.setComponentProps(this, props);\n    this.debuggerProps = [];\n  }\n\n  async init() {\n    this.markdownPath = \"getting-started/lifecycle-overview.md\";\n    this.markdownContent = \"---\\ntitle: LifeCycle Methods\\nroute: /Documentation/LifeCycle-Methods\\nnavLabel: LifeCycle Methods\\nsection: Getting Started\\ngroup: Components\\norder: 40\\ndescription: Overview of init, update, and beforeDestroy in Slice.js.\\ncomponent: LifeCycleMethods\\ntags: [lifecycle, init, update, destroy]\\n---\\n\\n# LifeCycle Methods\\n\\n## Overview\\nSlice.js components expose three lifecycle methods for predictable behavior:\\n\\n- `init()` for one-time setup\\n- `update()` for refreshes when data or routes change\\n- `beforeDestroy()` for cleanup and memory safety\\n\\nThese methods are called by the framework and are the recommended places to manage state,\\nsubscriptions, and DOM updates.\\n\\n## Lifecycle Summary\\n| Method | Called when | Async awaited | Typical responsibilities |\\n| --- | --- | --- | --- |\\n| `init()` | After construction, before first use | yes | Cache DOM, fetch initial data, build static children. |\\n| `update()` | When a cached route/component is reused | yes | Re-fetch data, rebuild dynamic lists, update state. |\\n| `beforeDestroy()` | Right before destruction | no | Cleanup timers, listeners, subscriptions, aborts. |\\n\\n## Call Order and Timing\\n```javascript title=\\\"Lifecycle timing\\\"\\nclass Example extends HTMLElement {\\n  async init() {\\n    // Runs once after template is attached and props are set\\n  }\\n\\n  async update() {\\n    // Runs when the component is reused or refreshed\\n  }\\n\\n  beforeDestroy() {\\n    // Runs right before the component is destroyed\\n  }\\n}\\n```\\n\\n## Navigation and Reuse\\n`update()` is called when a cached component is reused by routing (for example, `Route` and\\n`MultiRoute` containers). This keeps UI responsive without rebuilding static structure.\\n\\n## Recommended Structure\\n```javascript title=\\\"Recommended separation\\\"\\nclass UserList extends HTMLElement {\\n  async init() {\\n    this.$container = this.querySelector('.users');\\n    await this.loadUsers();\\n    await this.buildUserCards();\\n  }\\n\\n  async update() {\\n    slice.controller.destroyByContainer(this.$container);\\n    this.$container.innerHTML = '';\\n    await this.loadUsers();\\n    await this.buildUserCards();\\n  }\\n\\n  beforeDestroy() {\\n    clearInterval(this._pollingId);\\n    this.abortController?.abort();\\n  }\\n}\\n```\\n\\n## Best Practices\\n:::tip\\nKeep `init()` focused on one-time setup and cache DOM references there.\\n:::\\n\\n:::tip\\nUse `destroyByContainer` before rebuilding dynamic lists in `update()`.\\n:::\\n\\n## Gotchas\\n:::warning\\n`beforeDestroy()` is not awaited. Keep it synchronous or fire-and-forget.\\n:::\\n\\n:::warning\\nClearing `innerHTML` does not destroy Slice components. Use `destroyByContainer` first.\\n:::\\n\\n## Guides\\n- `init()`: /Documentation/LifeCycle-Methods/init\\n- `update()`: /Documentation/LifeCycle-Methods/update\\n- `beforeDestroy()`: /Documentation/LifeCycle-Methods/beforeDestroy\\n\";\n    if (true) {\n      this.setupCopyButton();\n    }\n      {\n         const container = this.querySelector('[data-block-id=\"doc-block-1\"]');\n         if (container) {\n            const lines = [\"| Method | Called when | Async awaited | Typical responsibilities |\",\"| --- | --- | --- | --- |\",\"| `init()` | After construction, before first use | yes | Cache DOM, fetch initial data, build static children. |\",\"| `update()` | When a cached route/component is reused | yes | Re-fetch data, rebuild dynamic lists, update state. |\",\"| `beforeDestroy()` | Right before destruction | no | Cleanup timers, listeners, subscriptions, aborts. |\"];\n            const clean = (line) => {\n               let value = line.trim();\n               if (value.startsWith('|')) {\n                  value = value.slice(1);\n               }\n               if (value.endsWith('|')) {\n                  value = value.slice(0, -1);\n               }\n               return value.split('|').map((cell) => cell.trim());\n            };\n\n            const formatCell = (text) => {\n               let output = text\n                  .replace(/&/g, '&amp;')\n                  .replace(/</g, '&lt;')\n                  .replace(/>/g, '&gt;');\n\n               const applyBold = (input) => {\n                  let result = '';\n                  let index = 0;\n                  while (index < input.length) {\n                     const start = input.indexOf('**', index);\n                     if (start === -1) {\n                        result += input.slice(index);\n                        break;\n                     }\n                     const end = input.indexOf('**', start + 2);\n                     if (end === -1) {\n                        result += input.slice(index);\n                        break;\n                     }\n                     result += input.slice(index, start) + '<strong>' + input.slice(start + 2, end) + '</strong>';\n                     index = end + 2;\n                  }\n                  return result;\n               };\n\n               const applyInlineCode = (input) => {\n                  const parts = input.split(String.fromCharCode(96));\n                  if (parts.length === 1) return input;\n                  return parts\n                     .map((part, idx) => (idx % 2 === 1 ? '<code>' + part + '</code>' : part))\n                     .join('');\n               };\n\n               output = applyBold(output);\n               output = applyInlineCode(output);\n               return output;\n            };\n\n            const headers = lines.length > 0 ? clean(lines[0]) : [];\n            const rows = lines.slice(2).map((line) => clean(line).map((cell) => formatCell(cell)));\n            const table = await slice.build('Table', { headers, rows });\n            container.appendChild(table);\n         }\n      }\n      {\n         const container = this.querySelector('[data-block-id=\"doc-block-2\"]');\n         if (container) {\n            const code = await slice.build('CodeVisualizer', {\n               value: \"class Example extends HTMLElement {\\n  async init() {\\n    // Runs once after template is attached and props are set\\n  }\\n\\n  async update() {\\n    // Runs when the component is reused or refreshed\\n  }\\n\\n  beforeDestroy() {\\n    // Runs right before the component is destroyed\\n  }\\n}\",\n               language: \"javascript\"\n            });\n            if (\"Lifecycle timing\") {\n               const label = document.createElement('div');\n               label.classList.add('code-block-title');\n               label.textContent = \"Lifecycle timing\";\n               container.appendChild(label);\n            }\n            container.appendChild(code);\n         }\n      }\n      {\n         const container = this.querySelector('[data-block-id=\"doc-block-3\"]');\n         if (container) {\n            const code = await slice.build('CodeVisualizer', {\n               value: \"class UserList extends HTMLElement {\\n  async init() {\\n    this.$container = this.querySelector('.users');\\n    await this.loadUsers();\\n    await this.buildUserCards();\\n  }\\n\\n  async update() {\\n    slice.controller.destroyByContainer(this.$container);\\n    this.$container.innerHTML = '';\\n    await this.loadUsers();\\n    await this.buildUserCards();\\n  }\\n\\n  beforeDestroy() {\\n    clearInterval(this._pollingId);\\n    this.abortController?.abort();\\n  }\\n}\",\n               language: \"javascript\"\n            });\n            if (\"Recommended separation\") {\n               const label = document.createElement('div');\n               label.classList.add('code-block-title');\n               label.textContent = \"Recommended separation\";\n               container.appendChild(label);\n            }\n            container.appendChild(code);\n         }\n      }\n  }\n\n  async update() {\n    // Refresh dynamic content here if needed\n  }\n\n  beforeDestroy() {\n    // Cleanup timers, listeners, or pending work here\n  }\n\n  async setupCopyButton() {\n    const container = this.querySelector('[data-copy-md]');\n    if (!container) return;\n\n    const copyMenu = await slice.build('CopyMarkdownMenu', {\n      markdownPath: this.markdownPath,\n      markdownContent: this.markdownContent,\n      label: '❐'\n    });\n\n    container.appendChild(copyMenu);\n  }\n\n  async copyMarkdown() {}\n}\n\nwindow.LifeCycleMethods = LifeCycleMethods;\ncustomElements.define('slice-lifecyclemethods', LifeCycleMethods);\n\nreturn LifeCycleMethods;",
    "externalDependencies": {},
    "componentDependencies": [
      "Table",
      "CodeVisualizer",
      "CopyMarkdownMenu"
    ],
    "html": "<div class=\"documentation-content lifecyclemethods\">\n\n<div class=\"doc-title-bar\">\n  <h1 id=\"lifecycle-methods\">\n    <span class=\"doc-title-text\">LifeCycle Methods</span>\n    <span class=\"copy-md-slot\" data-copy-md></span>\n  </h1>\n</div>\n<h2 id=\"overview\">Overview</h2>\n<p>Slice.js components expose three lifecycle methods for predictable behavior:</p>\n<ul><li><code>init()</code> for one-time setup</li><li><code>update()</code> for refreshes when data or routes change</li><li><code>beforeDestroy()</code> for cleanup and memory safety</li></ul>\n<p>These methods are called by the framework and are the recommended places to manage state, subscriptions, and DOM updates.</p>\n<h2 id=\"lifecycle-summary\">Lifecycle Summary</h2>\n<div class=\"table-block\" data-block-id=\"doc-block-1\"></div>\n<h2 id=\"call-order-and-timing\">Call Order and Timing</h2>\n<div class=\"code-block\" data-block-id=\"doc-block-2\"></div>\n<h2 id=\"navigation-and-reuse\">Navigation and Reuse</h2>\n<p><code>update()</code> is called when a cached component is reused by routing (for example, <code>Route</code> and <code>MultiRoute</code> containers). This keeps UI responsive without rebuilding static structure.</p>\n<h2 id=\"recommended-structure\">Recommended Structure</h2>\n<div class=\"code-block\" data-block-id=\"doc-block-3\"></div>\n<h2 id=\"best-practices\">Best Practices</h2>\n<div class=\"callout callout-tip\">Keep <code>init()</code> focused on one-time setup and cache DOM references there.</div>\n<div class=\"callout callout-tip\">Use <code>destroyByContainer</code> before rebuilding dynamic lists in <code>update()</code>.</div>\n<h2 id=\"gotchas\">Gotchas</h2>\n<div class=\"callout callout-warning\"><code>beforeDestroy()</code> is not awaited. Keep it synchronous or fire-and-forget.</div>\n<div class=\"callout callout-warning\">Clearing <code>innerHTML</code> does not destroy Slice components. Use <code>destroyByContainer</code> first.</div>\n<h2 id=\"guides\">Guides</h2>\n<ul><li><code>init()</code>: /Documentation/LifeCycle-Methods/init</li><li><code>update()</code>: /Documentation/LifeCycle-Methods/update</li><li><code>beforeDestroy()</code>: /Documentation/LifeCycle-Methods/beforeDestroy</li></ul>\n</div>\n",
    "css": "",
    "size": 10728
  },
  "InitMethodDocumentation": {
    "name": "InitMethodDocumentation",
    "category": "AppComponents",
    "categoryType": "Visual",
    "js": "class InitMethodDocumentation extends HTMLElement {\n  constructor(props) {\n    super();\n    slice.attachTemplate(this);\n    slice.controller.setComponentProps(this, props);\n    this.debuggerProps = [];\n  }\n\n  async init() {\n    this.markdownPath = \"getting-started/init-method.md\";\n    this.markdownContent = \"---\\ntitle: init()\\nroute: /Documentation/LifeCycle-Methods/init\\nnavLabel: init()\\nsection: Getting Started\\ngroup: Components\\norder: 41\\ndescription: One-time setup for Slice.js components.\\ncomponent: InitMethodDocumentation\\ntags: [lifecycle, init]\\n---\\n\\n# init()\\n\\n## Overview\\n`init()` runs once, right after the component instance is created and its template is attached.\\nUse it for one-time setup that should not repeat during updates.\\n\\n`slice.build()` awaits `init()` before returning the component instance.\\n\\n## API\\n| Method | Signature | Returns | Notes |\\n| --- | --- | --- | --- |\\n| `init` | `async init()` | `Promise<void>` | Called once per instance. |\\n\\n## Ideal Use Cases\\n- Cache DOM references\\n- Attach event listeners for the component lifetime\\n- Fetch initial data\\n- Build static child components\\n\\n## Example\\n```javascript title=\\\"One-time setup in init()\\\"\\nclass UserProfile extends HTMLElement {\\n  async init() {\\n    this.$userInfo = this.querySelector('.user-info');\\n    this.$avatar = this.querySelector('.avatar');\\n\\n    this.userData = await this.fetchUserData(this.userId);\\n\\n    this.editButton = await slice.build('Button', {\\n      sliceId: 'edit-profile-btn',\\n      value: 'Edit Profile',\\n      onClickCallback: () => this.editProfile()\\n    });\\n\\n    this.addEventListener('click', this.handleClick.bind(this));\\n\\n    this.updateUserUI();\\n    this.appendChild(this.editButton);\\n  }\\n\\n  updateUserUI() {\\n    this.$userInfo.textContent = this.userData.name;\\n    this.$avatar.src = this.userData.avatar;\\n  }\\n}\\n```\\n\\n## Patterns\\n```javascript title=\\\"Bind events with auto-cleanup\\\"\\nclass Notifications extends HTMLElement {\\n  async init() {\\n    this.events = slice.events.bind(this);\\n    this.events.subscribe('notify', (payload) => this.show(payload));\\n  }\\n}\\n```\\n\\n## Best Practices\\n:::tip\\nQuery DOM elements in `init()` (not in the constructor).\\n:::\\n\\n:::tip\\nBuild static child components here. Dynamic lists belong in `update()`.\\n:::\\n\\n## Gotchas\\n:::warning\\nAvoid building dynamic lists in `init()` if the list needs to refresh.\\n:::\\n\";\n    if (true) {\n      this.setupCopyButton();\n    }\n      {\n         const container = this.querySelector('[data-block-id=\"doc-block-1\"]');\n         if (container) {\n            const lines = [\"| Method | Signature | Returns | Notes |\",\"| --- | --- | --- | --- |\",\"| `init` | `async init()` | `Promise<void>` | Called once per instance. |\"];\n            const clean = (line) => {\n               let value = line.trim();\n               if (value.startsWith('|')) {\n                  value = value.slice(1);\n               }\n               if (value.endsWith('|')) {\n                  value = value.slice(0, -1);\n               }\n               return value.split('|').map((cell) => cell.trim());\n            };\n\n            const formatCell = (text) => {\n               let output = text\n                  .replace(/&/g, '&amp;')\n                  .replace(/</g, '&lt;')\n                  .replace(/>/g, '&gt;');\n\n               const applyBold = (input) => {\n                  let result = '';\n                  let index = 0;\n                  while (index < input.length) {\n                     const start = input.indexOf('**', index);\n                     if (start === -1) {\n                        result += input.slice(index);\n                        break;\n                     }\n                     const end = input.indexOf('**', start + 2);\n                     if (end === -1) {\n                        result += input.slice(index);\n                        break;\n                     }\n                     result += input.slice(index, start) + '<strong>' + input.slice(start + 2, end) + '</strong>';\n                     index = end + 2;\n                  }\n                  return result;\n               };\n\n               const applyInlineCode = (input) => {\n                  const parts = input.split(String.fromCharCode(96));\n                  if (parts.length === 1) return input;\n                  return parts\n                     .map((part, idx) => (idx % 2 === 1 ? '<code>' + part + '</code>' : part))\n                     .join('');\n               };\n\n               output = applyBold(output);\n               output = applyInlineCode(output);\n               return output;\n            };\n\n            const headers = lines.length > 0 ? clean(lines[0]) : [];\n            const rows = lines.slice(2).map((line) => clean(line).map((cell) => formatCell(cell)));\n            const table = await slice.build('Table', { headers, rows });\n            container.appendChild(table);\n         }\n      }\n      {\n         const container = this.querySelector('[data-block-id=\"doc-block-2\"]');\n         if (container) {\n            const code = await slice.build('CodeVisualizer', {\n               value: \"class UserProfile extends HTMLElement {\\n  async init() {\\n    this.$userInfo = this.querySelector('.user-info');\\n    this.$avatar = this.querySelector('.avatar');\\n\\n    this.userData = await this.fetchUserData(this.userId);\\n\\n    this.editButton = await slice.build('Button', {\\n      sliceId: 'edit-profile-btn',\\n      value: 'Edit Profile',\\n      onClickCallback: () => this.editProfile()\\n    });\\n\\n    this.addEventListener('click', this.handleClick.bind(this));\\n\\n    this.updateUserUI();\\n    this.appendChild(this.editButton);\\n  }\\n\\n  updateUserUI() {\\n    this.$userInfo.textContent = this.userData.name;\\n    this.$avatar.src = this.userData.avatar;\\n  }\\n}\",\n               language: \"javascript\"\n            });\n            if (\"One-time setup in init()\") {\n               const label = document.createElement('div');\n               label.classList.add('code-block-title');\n               label.textContent = \"One-time setup in init()\";\n               container.appendChild(label);\n            }\n            container.appendChild(code);\n         }\n      }\n      {\n         const container = this.querySelector('[data-block-id=\"doc-block-3\"]');\n         if (container) {\n            const code = await slice.build('CodeVisualizer', {\n               value: \"class Notifications extends HTMLElement {\\n  async init() {\\n    this.events = slice.events.bind(this);\\n    this.events.subscribe('notify', (payload) => this.show(payload));\\n  }\\n}\",\n               language: \"javascript\"\n            });\n            if (\"Bind events with auto-cleanup\") {\n               const label = document.createElement('div');\n               label.classList.add('code-block-title');\n               label.textContent = \"Bind events with auto-cleanup\";\n               container.appendChild(label);\n            }\n            container.appendChild(code);\n         }\n      }\n  }\n\n  async update() {\n    // Refresh dynamic content here if needed\n  }\n\n  beforeDestroy() {\n    // Cleanup timers, listeners, or pending work here\n  }\n\n  async setupCopyButton() {\n    const container = this.querySelector('[data-copy-md]');\n    if (!container) return;\n\n    const copyMenu = await slice.build('CopyMarkdownMenu', {\n      markdownPath: this.markdownPath,\n      markdownContent: this.markdownContent,\n      label: '❐'\n    });\n\n    container.appendChild(copyMenu);\n  }\n\n  async copyMarkdown() {}\n}\n\nwindow.InitMethodDocumentation = InitMethodDocumentation;\ncustomElements.define('slice-initmethoddocumentation', InitMethodDocumentation);\n\nreturn InitMethodDocumentation;",
    "externalDependencies": {},
    "componentDependencies": [
      "Table",
      "CodeVisualizer",
      "CopyMarkdownMenu"
    ],
    "html": "<div class=\"documentation-content initmethoddocumentation\">\n\n<div class=\"doc-title-bar\">\n  <h1 id=\"init\">\n    <span class=\"doc-title-text\">init()</span>\n    <span class=\"copy-md-slot\" data-copy-md></span>\n  </h1>\n</div>\n<h2 id=\"overview\">Overview</h2>\n<p><code>init()</code> runs once, right after the component instance is created and its template is attached. Use it for one-time setup that should not repeat during updates.</p>\n<p><code>slice.build()</code> awaits <code>init()</code> before returning the component instance.</p>\n<h2 id=\"api\">API</h2>\n<div class=\"table-block\" data-block-id=\"doc-block-1\"></div>\n<h2 id=\"ideal-use-cases\">Ideal Use Cases</h2>\n<ul><li>Cache DOM references</li><li>Attach event listeners for the component lifetime</li><li>Fetch initial data</li><li>Build static child components</li></ul>\n<h2 id=\"example\">Example</h2>\n<div class=\"code-block\" data-block-id=\"doc-block-2\"></div>\n<h2 id=\"patterns\">Patterns</h2>\n<div class=\"code-block\" data-block-id=\"doc-block-3\"></div>\n<h2 id=\"best-practices\">Best Practices</h2>\n<div class=\"callout callout-tip\">Query DOM elements in <code>init()</code> (not in the constructor).</div>\n<div class=\"callout callout-tip\">Build static child components here. Dynamic lists belong in <code>update()</code>.</div>\n<h2 id=\"gotchas\">Gotchas</h2>\n<div class=\"callout callout-warning\">Avoid building dynamic lists in <code>init()</code> if the list needs to refresh.</div>\n</div>\n",
    "css": "/* init() Method Documentation Styles */\n\nslice-initmethoddocumentation {\n  color: var(--font-primary-color);\n  display: block;\n  max-width: 1200px;\n  margin: 0 auto;\n  padding: 20px;\n  line-height: 1.6;\n}\n\nslice-initmethoddocumentation h1,\nslice-initmethoddocumentation h2,\nslice-initmethoddocumentation h3 {\n  margin-top: 1.5em;\n  margin-bottom: 0.5em;\n}\n\nslice-initmethoddocumentation h1 {\n  text-align: center;\n  border-bottom: 3px solid var(--primary-color);\n  padding-bottom: 12px;\n}\n\nslice-initmethoddocumentation h2 {\n  border-bottom: 1px solid var(--primary-color-shade);\n  padding-bottom: 8px;\n}\n\nslice-initmethoddocumentation p {\n  margin: 1em 0;\n}\n\nslice-initmethoddocumentation ul {\n  margin: 1em 0;\n  padding-left: 2em;\n}\n\nslice-initmethoddocumentation li {\n  margin-bottom: 0.5em;\n}\n\nslice-initmethoddocumentation code {\n  font-family: monospace;\n  background-color: var(--secondary-background-color);\n  padding: 0.2em 0.4em;\n  border-radius: 3px;\n  font-size: 0.9em;\n}\n\nslice-initmethoddocumentation .init-example,\nslice-initmethoddocumentation .best-practices,\nslice-initmethoddocumentation .pitfalls {\n  margin: 1.5em 0;\n}\n\n@media (max-width: 768px) {\n  slice-initmethoddocumentation {\n    padding: 15px;\n  }\n}\n",
    "size": 10366
  },
  "UpdateMethodDocumentation": {
    "name": "UpdateMethodDocumentation",
    "category": "AppComponents",
    "categoryType": "Visual",
    "js": "class UpdateMethodDocumentation extends HTMLElement {\n  constructor(props) {\n    super();\n    slice.attachTemplate(this);\n    slice.controller.setComponentProps(this, props);\n    this.debuggerProps = [];\n  }\n\n  async init() {\n    this.markdownPath = \"getting-started/update-method.md\";\n    this.markdownContent = \"---\\ntitle: update()\\nroute: /Documentation/LifeCycle-Methods/update\\nnavLabel: update()\\nsection: Getting Started\\ngroup: Components\\norder: 42\\ndescription: Refresh dynamic UI in Slice.js components.\\ncomponent: UpdateMethodDocumentation\\ntags: [lifecycle, update]\\n---\\n\\n# update()\\n\\n## Overview\\n`update()` runs whenever a component needs to refresh. The router calls it when a cached\\ncomponent is reused by `Route` or `MultiRoute`. You can also call it manually after changing\\nprops or state.\\n\\n## API\\n| Method | Signature | Returns | Notes |\\n| --- | --- | --- | --- |\\n| `update` | `async update()` | `Promise<void>` | Called on cached components when revisited. |\\n\\n## Ideal Use Cases\\n- Re-fetch data that can change\\n- Rebuild dynamic child components\\n- Re-apply dynamic state to the DOM\\n\\n## Example\\n```javascript title=\\\"Rebuild dynamic UI in update()\\\"\\nclass ProductList extends HTMLElement {\\n  async init() {\\n    this.$productContainer = this.querySelector('.products-container');\\n    await this.loadAndRenderProducts();\\n  }\\n\\n  async update() {\\n    slice.controller.destroyByContainer(this.$productContainer);\\n    this.$productContainer.innerHTML = '';\\n    await this.loadAndRenderProducts();\\n  }\\n\\n  async loadAndRenderProducts() {\\n    this.products = await this.fetchProducts();\\n\\n    for (const product of this.products) {\\n      const productCard = await slice.build('ProductCard', {\\n        sliceId: `product-${product.id}`,\\n        title: product.title,\\n        price: product.price,\\n        image: product.image\\n      });\\n\\n      this.$productContainer.appendChild(productCard);\\n    }\\n  }\\n}\\n```\\n\\n## Best Practices\\n:::steps\\n1. Destroy old components with `destroyByContainer`.\\n2. Clear the container.\\n3. Fetch fresh data.\\n4. Rebuild components with stable `sliceId`s.\\n:::\\n\\n:::tip\\nKeep `update()` idempotent and safe to call multiple times.\\n:::\\n\\n## Gotchas\\n:::warning\\nClearing `innerHTML` alone does not destroy Slice components.\\n:::\\n\\n:::warning\\nDo not rebuild static UI in `update()` unless it depends on changing data.\\n:::\\n\";\n    if (true) {\n      this.setupCopyButton();\n    }\n      {\n         const container = this.querySelector('[data-block-id=\"doc-block-1\"]');\n         if (container) {\n            const lines = [\"| Method | Signature | Returns | Notes |\",\"| --- | --- | --- | --- |\",\"| `update` | `async update()` | `Promise<void>` | Called on cached components when revisited. |\"];\n            const clean = (line) => {\n               let value = line.trim();\n               if (value.startsWith('|')) {\n                  value = value.slice(1);\n               }\n               if (value.endsWith('|')) {\n                  value = value.slice(0, -1);\n               }\n               return value.split('|').map((cell) => cell.trim());\n            };\n\n            const formatCell = (text) => {\n               let output = text\n                  .replace(/&/g, '&amp;')\n                  .replace(/</g, '&lt;')\n                  .replace(/>/g, '&gt;');\n\n               const applyBold = (input) => {\n                  let result = '';\n                  let index = 0;\n                  while (index < input.length) {\n                     const start = input.indexOf('**', index);\n                     if (start === -1) {\n                        result += input.slice(index);\n                        break;\n                     }\n                     const end = input.indexOf('**', start + 2);\n                     if (end === -1) {\n                        result += input.slice(index);\n                        break;\n                     }\n                     result += input.slice(index, start) + '<strong>' + input.slice(start + 2, end) + '</strong>';\n                     index = end + 2;\n                  }\n                  return result;\n               };\n\n               const applyInlineCode = (input) => {\n                  const parts = input.split(String.fromCharCode(96));\n                  if (parts.length === 1) return input;\n                  return parts\n                     .map((part, idx) => (idx % 2 === 1 ? '<code>' + part + '</code>' : part))\n                     .join('');\n               };\n\n               output = applyBold(output);\n               output = applyInlineCode(output);\n               return output;\n            };\n\n            const headers = lines.length > 0 ? clean(lines[0]) : [];\n            const rows = lines.slice(2).map((line) => clean(line).map((cell) => formatCell(cell)));\n            const table = await slice.build('Table', { headers, rows });\n            container.appendChild(table);\n         }\n      }\n      {\n         const container = this.querySelector('[data-block-id=\"doc-block-2\"]');\n         if (container) {\n            const code = await slice.build('CodeVisualizer', {\n               value: \"class ProductList extends HTMLElement {\\n  async init() {\\n    this.$productContainer = this.querySelector('.products-container');\\n    await this.loadAndRenderProducts();\\n  }\\n\\n  async update() {\\n    slice.controller.destroyByContainer(this.$productContainer);\\n    this.$productContainer.innerHTML = '';\\n    await this.loadAndRenderProducts();\\n  }\\n\\n  async loadAndRenderProducts() {\\n    this.products = await this.fetchProducts();\\n\\n    for (const product of this.products) {\\n      const productCard = await slice.build('ProductCard', {\\n        sliceId: `product-${product.id}`,\\n        title: product.title,\\n        price: product.price,\\n        image: product.image\\n      });\\n\\n      this.$productContainer.appendChild(productCard);\\n    }\\n  }\\n}\",\n               language: \"javascript\"\n            });\n            if (\"Rebuild dynamic UI in update()\") {\n               const label = document.createElement('div');\n               label.classList.add('code-block-title');\n               label.textContent = \"Rebuild dynamic UI in update()\";\n               container.appendChild(label);\n            }\n            container.appendChild(code);\n         }\n      }\n  }\n\n  async update() {\n    // Refresh dynamic content here if needed\n  }\n\n  beforeDestroy() {\n    // Cleanup timers, listeners, or pending work here\n  }\n\n  async setupCopyButton() {\n    const container = this.querySelector('[data-copy-md]');\n    if (!container) return;\n\n    const copyMenu = await slice.build('CopyMarkdownMenu', {\n      markdownPath: this.markdownPath,\n      markdownContent: this.markdownContent,\n      label: '❐'\n    });\n\n    container.appendChild(copyMenu);\n  }\n\n  async copyMarkdown() {}\n}\n\nwindow.UpdateMethodDocumentation = UpdateMethodDocumentation;\ncustomElements.define('slice-updatemethoddocumentation', UpdateMethodDocumentation);\n\nreturn UpdateMethodDocumentation;",
    "externalDependencies": {},
    "componentDependencies": [
      "Table",
      "CodeVisualizer",
      "CopyMarkdownMenu"
    ],
    "html": "<div class=\"documentation-content updatemethoddocumentation\">\n\n<div class=\"doc-title-bar\">\n  <h1 id=\"update\">\n    <span class=\"doc-title-text\">update()</span>\n    <span class=\"copy-md-slot\" data-copy-md></span>\n  </h1>\n</div>\n<h2 id=\"overview\">Overview</h2>\n<p><code>update()</code> runs whenever a component needs to refresh. The router calls it when a cached component is reused by <code>Route</code> or <code>MultiRoute</code>. You can also call it manually after changing props or state.</p>\n<h2 id=\"api\">API</h2>\n<div class=\"table-block\" data-block-id=\"doc-block-1\"></div>\n<h2 id=\"ideal-use-cases\">Ideal Use Cases</h2>\n<ul><li>Re-fetch data that can change</li><li>Rebuild dynamic child components</li><li>Re-apply dynamic state to the DOM</li></ul>\n<h2 id=\"example\">Example</h2>\n<div class=\"code-block\" data-block-id=\"doc-block-2\"></div>\n<h2 id=\"best-practices\">Best Practices</h2>\n<ol class=\"steps\"><li>Destroy old components with <code>destroyByContainer</code>.</li><li>Clear the container.</li><li>Fetch fresh data.</li><li>Rebuild components with stable <code>sliceId</code>s.</li></ol>\n<div class=\"callout callout-tip\">Keep <code>update()</code> idempotent and safe to call multiple times.</div>\n<h2 id=\"gotchas\">Gotchas</h2>\n<div class=\"callout callout-warning\">Clearing <code>innerHTML</code> alone does not destroy Slice components.</div>\n<div class=\"callout callout-warning\">Do not rebuild static UI in <code>update()</code> unless it depends on changing data.</div>\n</div>\n",
    "css": "/* update() Method Documentation Styles */\n\nslice-updatemethoddocumentation {\n  color: var(--font-primary-color);\n  display: block;\n  max-width: 1200px;\n  margin: 0 auto;\n  padding: 20px;\n  line-height: 1.6;\n}\n\nslice-updatemethoddocumentation h1,\nslice-updatemethoddocumentation h2,\nslice-updatemethoddocumentation h3 {\n  margin-top: 1.5em;\n  margin-bottom: 0.5em;\n}\n\nslice-updatemethoddocumentation h1 {\n  text-align: center;\n  border-bottom: 3px solid var(--primary-color);\n  padding-bottom: 12px;\n}\n\nslice-updatemethoddocumentation h2 {\n  border-bottom: 1px solid var(--primary-color-shade);\n  padding-bottom: 8px;\n}\n\nslice-updatemethoddocumentation p {\n  margin: 1em 0;\n}\n\nslice-updatemethoddocumentation ul {\n  margin: 1em 0;\n  padding-left: 2em;\n}\n\nslice-updatemethoddocumentation li {\n  margin-bottom: 0.5em;\n}\n\nslice-updatemethoddocumentation code {\n  font-family: monospace;\n  background-color: var(--secondary-background-color);\n  padding: 0.2em 0.4em;\n  border-radius: 3px;\n  font-size: 0.9em;\n}\n\nslice-updatemethoddocumentation .update-example,\nslice-updatemethoddocumentation .best-practices,\nslice-updatemethoddocumentation .pitfalls {\n  margin: 1.5em 0;\n}\n\n@media (max-width: 768px) {\n  slice-updatemethoddocumentation {\n    padding: 15px;\n  }\n}\n",
    "size": 9737
  },
  "BeforeDestroyDocumentation": {
    "name": "BeforeDestroyDocumentation",
    "category": "AppComponents",
    "categoryType": "Visual",
    "js": "class BeforeDestroyDocumentation extends HTMLElement {\n  constructor(props) {\n    super();\n    slice.attachTemplate(this);\n    slice.controller.setComponentProps(this, props);\n    this.debuggerProps = [];\n  }\n\n  async init() {\n    this.markdownPath = \"getting-started/before-destroy.md\";\n    this.markdownContent = \"---\\ntitle: beforeDestroy()\\nroute: /Documentation/LifeCycle-Methods/beforeDestroy\\nnavLabel: beforeDestroy()\\nsection: Getting Started\\ngroup: Components\\norder: 43\\ndescription: Cleanup hooks to avoid memory leaks in Slice.js.\\ncomponent: BeforeDestroyDocumentation\\ntags: [lifecycle, destroy, cleanup]\\n---\\n\\n# beforeDestroy()\\n\\n## Overview\\n`beforeDestroy()` runs right before a component is destroyed by the controller. Use it for\\ncleanup: timers, listeners, subscriptions, and pending async work.\\n\\nThe controller does not await this method, so keep it synchronous or fire-and-forget.\\n\\n## API\\n| Method | Signature | Returns | Notes |\\n| --- | --- | --- | --- |\\n| `beforeDestroy` | `beforeDestroy()` | `void` | Called right before the component is removed. |\\n\\n## Ideal Use Cases\\n- Clear intervals and timeouts\\n- Abort pending fetch requests\\n- Remove global event listeners\\n- Dispose third-party instances (charts, maps, etc.)\\n\\n## Example\\n```javascript title=\\\"Cleanup in beforeDestroy()\\\"\\nclass LiveChart extends HTMLElement {\\n  constructor(props) {\\n    super();\\n    slice.attachTemplate(this);\\n    slice.controller.setComponentProps(this, props);\\n    this.abortController = new AbortController();\\n  }\\n\\n  async init() {\\n    this._pollingId = setInterval(() => this.fetchData(), 5000);\\n    window.addEventListener('resize', this.onResize);\\n    await fetch('/api/chart', { signal: this.abortController.signal });\\n  }\\n\\n  beforeDestroy() {\\n    clearInterval(this._pollingId);\\n    this.abortController.abort();\\n    window.removeEventListener('resize', this.onResize);\\n    this.chartInstance?.destroy();\\n  }\\n}\\n```\\n\\n## Best Practices\\n:::tip\\nKeep `beforeDestroy()` idempotent so it can be called safely.\\n:::\\n\\n:::tip\\nUse `AbortController` for fetch cleanup.\\n:::\\n\\n## Gotchas\\n:::warning\\nIf you add global listeners in `init()`, remove them in `beforeDestroy()`.\\n:::\\n\\n:::warning\\nDo not rely on `await` inside `beforeDestroy()`.\\n:::\\n\";\n    if (true) {\n      this.setupCopyButton();\n    }\n      {\n         const container = this.querySelector('[data-block-id=\"doc-block-1\"]');\n         if (container) {\n            const lines = [\"| Method | Signature | Returns | Notes |\",\"| --- | --- | --- | --- |\",\"| `beforeDestroy` | `beforeDestroy()` | `void` | Called right before the component is removed. |\"];\n            const clean = (line) => {\n               let value = line.trim();\n               if (value.startsWith('|')) {\n                  value = value.slice(1);\n               }\n               if (value.endsWith('|')) {\n                  value = value.slice(0, -1);\n               }\n               return value.split('|').map((cell) => cell.trim());\n            };\n\n            const formatCell = (text) => {\n               let output = text\n                  .replace(/&/g, '&amp;')\n                  .replace(/</g, '&lt;')\n                  .replace(/>/g, '&gt;');\n\n               const applyBold = (input) => {\n                  let result = '';\n                  let index = 0;\n                  while (index < input.length) {\n                     const start = input.indexOf('**', index);\n                     if (start === -1) {\n                        result += input.slice(index);\n                        break;\n                     }\n                     const end = input.indexOf('**', start + 2);\n                     if (end === -1) {\n                        result += input.slice(index);\n                        break;\n                     }\n                     result += input.slice(index, start) + '<strong>' + input.slice(start + 2, end) + '</strong>';\n                     index = end + 2;\n                  }\n                  return result;\n               };\n\n               const applyInlineCode = (input) => {\n                  const parts = input.split(String.fromCharCode(96));\n                  if (parts.length === 1) return input;\n                  return parts\n                     .map((part, idx) => (idx % 2 === 1 ? '<code>' + part + '</code>' : part))\n                     .join('');\n               };\n\n               output = applyBold(output);\n               output = applyInlineCode(output);\n               return output;\n            };\n\n            const headers = lines.length > 0 ? clean(lines[0]) : [];\n            const rows = lines.slice(2).map((line) => clean(line).map((cell) => formatCell(cell)));\n            const table = await slice.build('Table', { headers, rows });\n            container.appendChild(table);\n         }\n      }\n      {\n         const container = this.querySelector('[data-block-id=\"doc-block-2\"]');\n         if (container) {\n            const code = await slice.build('CodeVisualizer', {\n               value: \"class LiveChart extends HTMLElement {\\n  constructor(props) {\\n    super();\\n    slice.attachTemplate(this);\\n    slice.controller.setComponentProps(this, props);\\n    this.abortController = new AbortController();\\n  }\\n\\n  async init() {\\n    this._pollingId = setInterval(() => this.fetchData(), 5000);\\n    window.addEventListener('resize', this.onResize);\\n    await fetch('/api/chart', { signal: this.abortController.signal });\\n  }\\n\\n  beforeDestroy() {\\n    clearInterval(this._pollingId);\\n    this.abortController.abort();\\n    window.removeEventListener('resize', this.onResize);\\n    this.chartInstance?.destroy();\\n  }\\n}\",\n               language: \"javascript\"\n            });\n            if (\"Cleanup in beforeDestroy()\") {\n               const label = document.createElement('div');\n               label.classList.add('code-block-title');\n               label.textContent = \"Cleanup in beforeDestroy()\";\n               container.appendChild(label);\n            }\n            container.appendChild(code);\n         }\n      }\n  }\n\n  async update() {\n    // Refresh dynamic content here if needed\n  }\n\n  beforeDestroy() {\n    // Cleanup timers, listeners, or pending work here\n  }\n\n  async setupCopyButton() {\n    const container = this.querySelector('[data-copy-md]');\n    if (!container) return;\n\n    const copyMenu = await slice.build('CopyMarkdownMenu', {\n      markdownPath: this.markdownPath,\n      markdownContent: this.markdownContent,\n      label: '❐'\n    });\n\n    container.appendChild(copyMenu);\n  }\n\n  async copyMarkdown() {}\n}\n\nwindow.BeforeDestroyDocumentation = BeforeDestroyDocumentation;\ncustomElements.define('slice-beforedestroydocumentation', BeforeDestroyDocumentation);\n\nreturn BeforeDestroyDocumentation;",
    "externalDependencies": {},
    "componentDependencies": [
      "Table",
      "CodeVisualizer",
      "CopyMarkdownMenu"
    ],
    "html": "<div class=\"documentation-content beforedestroydocumentation\">\n\n<div class=\"doc-title-bar\">\n  <h1 id=\"beforedestroy\">\n    <span class=\"doc-title-text\">beforeDestroy()</span>\n    <span class=\"copy-md-slot\" data-copy-md></span>\n  </h1>\n</div>\n<h2 id=\"overview\">Overview</h2>\n<p><code>beforeDestroy()</code> runs right before a component is destroyed by the controller. Use it for cleanup: timers, listeners, subscriptions, and pending async work.</p>\n<p>The controller does not await this method, so keep it synchronous or fire-and-forget.</p>\n<h2 id=\"api\">API</h2>\n<div class=\"table-block\" data-block-id=\"doc-block-1\"></div>\n<h2 id=\"ideal-use-cases\">Ideal Use Cases</h2>\n<ul><li>Clear intervals and timeouts</li><li>Abort pending fetch requests</li><li>Remove global event listeners</li><li>Dispose third-party instances (charts, maps, etc.)</li></ul>\n<h2 id=\"example\">Example</h2>\n<div class=\"code-block\" data-block-id=\"doc-block-2\"></div>\n<h2 id=\"best-practices\">Best Practices</h2>\n<div class=\"callout callout-tip\">Keep <code>beforeDestroy()</code> idempotent so it can be called safely.</div>\n<div class=\"callout callout-tip\">Use <code>AbortController</code> for fetch cleanup.</div>\n<h2 id=\"gotchas\">Gotchas</h2>\n<div class=\"callout callout-warning\">If you add global listeners in <code>init()</code>, remove them in <code>beforeDestroy()</code>.</div>\n<div class=\"callout callout-warning\">Do not rely on <code>await</code> inside <code>beforeDestroy()</code>.</div>\n</div>\n",
    "css": "/* beforeDestroy() Method Documentation Styles */\n\nslice-beforedestroydocumentation {\n  color: var(--font-primary-color);\n  display: block;\n  max-width: 1200px;\n  margin: 0 auto;\n  padding: 20px;\n  line-height: 1.6;\n}\n\nslice-beforedestroydocumentation h1,\nslice-beforedestroydocumentation h2,\nslice-beforedestroydocumentation h3 {\n  margin-top: 1.5em;\n  margin-bottom: 0.5em;\n}\n\nslice-beforedestroydocumentation h1 {\n  text-align: center;\n  border-bottom: 3px solid var(--primary-color);\n  padding-bottom: 12px;\n}\n\nslice-beforedestroydocumentation h2 {\n  border-bottom: 1px solid var(--primary-color-shade);\n  padding-bottom: 8px;\n}\n\nslice-beforedestroydocumentation p {\n  margin: 1em 0;\n}\n\nslice-beforedestroydocumentation ul {\n  margin: 1em 0;\n  padding-left: 2em;\n}\n\nslice-beforedestroydocumentation li {\n  margin-bottom: 0.5em;\n}\n\nslice-beforedestroydocumentation code {\n  font-family: monospace;\n  background-color: var(--secondary-background-color);\n  padding: 0.2em 0.4em;\n  border-radius: 3px;\n  font-size: 0.9em;\n}\n\nslice-beforedestroydocumentation .before-destroy-example,\nslice-beforedestroydocumentation .best-practices,\nslice-beforedestroydocumentation .pitfalls {\n  margin: 1.5em 0;\n}\n\n@media (max-width: 768px) {\n  slice-beforedestroydocumentation {\n    padding: 15px;\n  }\n}\n",
    "size": 9501
  }
}
};

// Auto-registration of components
if (window.slice && window.slice.controller) {
  slice.controller.registerBundle(SLICE_BUNDLE);
}
