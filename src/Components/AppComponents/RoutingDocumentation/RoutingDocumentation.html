<div class="routingdocumentation">
  <h1 id="routing">Routing in Slice.js</h1>
  <p>
    The routing system in Slice.js provides a powerful, declarative way to define and manage navigation
    in your single-page applications. It automatically handles browser history, component rendering, and
    provides multiple ways to define and organize routes.
  </p>

  <h2 id="router-components">Router Components</h2>
  <p>
    Slice.js offers three main components for routing, each designed for different use cases:
  </p>
  <ul>
    <li>
      <strong>Route</strong>: Renders a single route component based on the current path.
      Ideal for simple routing scenarios.
    </li>
    <li>
      <strong>MultiRoute</strong>: Manages multiple related routes in a single container.
      Perfect for organizing sections of your app with shared layouts or nested routes.
    </li>
    <li>
      <strong>Router (Structural)</strong>: The core routing engine that powers both Route and MultiRoute.
      Handles navigation, history, and route matching.
    </li>
  </ul>

  <h2 id="basic-routing">Basic Routing with Route Component</h2>
  <p>
    The Route component is the simplest way to implement routing. It takes a single route configuration
    and renders the appropriate component when the path matches.
  </p>

  <div class="basic-route-example"></div>

  <h2 id="route-configuration">Route Configuration</h2>
  <p>
    Routes are typically defined in a central <code>routes.js</code> file. Each route object specifies
    a path, the component to render, and optional metadata.
  </p>

  <div class="route-config-example"></div>

  <h2 id="multi-route">MultiRoute Component</h2>
  <p>
    When you need to manage multiple routes in a section of your application, use the MultiRoute component.
    It's particularly useful for organizing related routes and implementing layouts with nested content areas.
  </p>

  <div class="multi-route-example"></div>

  <h2 id="dynamic-routes">Dynamic Route Parameters</h2>
  <p>
    Slice.js supports dynamic route segments using the <code>${paramName}</code> syntax in route paths.
    These parameters are then passed to your component through the <code>props.params</code> object.
  </p>

  <div class="dynamic-routes-example"></div>

  <p>
    When a dynamic route matches, the parameters are extracted from the URL and made available to your component.
    This allows you to create reusable components that can display different content based on the URL parameters.
  </p>

  <h2 id="navigation-methods">Navigation Methods</h2>
  <p>
    Slice.js provides multiple ways to navigate between routes: programmatically using the router API, 
    and automatically through anchor elements.
  </p>

  <h3 id="programmatic-navigation">Programmatic Navigation</h3>
  <p>
    Use the <code>slice.router.navigate()</code> method for programmatic navigation in your JavaScript code.
    This is ideal for conditional navigation, redirects, or navigation triggered by user actions other than link clicks.
  </p>

  <h3 id="anchor-navigation">Anchor Element Navigation</h3>
  <p>
    The router automatically intercepts clicks on anchor elements (<code>&lt;a href="/path"&gt;</code>) 
    for internal links, providing seamless navigation without page reloads. No special setup is required - 
    just use standard HTML anchor elements and the router handles the rest.
  </p>

  <h4>Links that are NOT intercepted</h4>
  <ul>
    <li><strong>External links</strong>: Links to different domains</li>
    <li><strong>Special protocols</strong>: Links using <code>mailto:</code>, <code>tel:</code>, <code>ftp:</code>, etc.</li>
    <li><strong>Hash links</strong>: Links starting with <code>#</code> for same-page anchors</li>
    <li><strong>Download links</strong>: Links with the <code>download</code> attribute</li>
    <li><strong>Target attributes</strong>: Links with <code>target="_blank"</code>, <code>target="_top"</code>, etc.</li>
    <li><strong>Marked as external</strong>: Links with <code>class="external-link"</code></li>
  </ul>

  <div class="programmatic-nav-example"></div>

  <h2 id="navigation-guards">Navigation Guards</h2>
  <p>
    Navigation Guards are powerful hooks that allow you to control and respond to navigation events. They're
    essential for implementing authentication, authorization, data prefetching, analytics, and other
    navigation-related logic.
  </p>

  <h3 id="guard-hooks">Guard Hooks</h3>
  <p>
    Slice.js provides two navigation guard hooks that must be defined <strong>before</strong> starting the router:
  </p>

  <ul>
    <li>
      <strong>beforeEach</strong>: Called before every navigation. Can prevent or redirect navigation.
      Perfect for authentication checks, route protection, and data validation.
    </li>
    <li>
      <strong>afterEach</strong>: Called after navigation completes. Ideal for analytics tracking,
      updating page titles, resetting scroll position, and cleanup tasks.
    </li>
  </ul>

  <div class="navigation-guards-example"></div>

  <p>
    <strong>ðŸ“š Complete Guide:</strong> For comprehensive documentation on Navigation Guards including
    authentication patterns, role-based authorization, data prefetching, composable guards, and best practices,
    see the <strong>Router Guards Documentation</strong>.
  </p>

  <h3 id="starting-router">Starting the Router</h3>
  <p>
    When using navigation guards, you must explicitly start the router <strong>after</strong> defining all guards.
    If you don't define any guards, the router starts automatically during initialization.
  </p>

  <div class="starting-router-example"></div>

  <h2 id="nested-routes">Nested Routes and Layouts</h2>
  <p>
    Slice.js supports nested routes, which are powerful for creating complex UIs with shared layouts. You can
    define child routes in the route configuration, and they will inherit the parent route's path as a prefix.
  </p>

  <div class="nested-routes-example"></div>

  <h2 id="dynamic-route-management">Dynamic Route Management</h2>
  <p>
    The router supports adding, removing, and updating routes at runtime, providing flexibility for dynamic applications:
  </p>
  <ul>
    <li><strong>Add routes</strong>: <code>slice.router.addRoute({ path: "/new", component: "NewComponent" })</code></li>
    <li><strong>Remove routes</strong>: <code>slice.router.removeRoute("/old-path")</code></li>
    <li><strong>Update routes</strong>: <code>slice.router.updateRoutes(newRoutesArray)</code></li>
    <li><strong>Get all routes</strong>: <code>slice.router.getAllRoutes()</code></li>
  </ul>

  <h2 id="route-lifecycle">Route Lifecycle and Events</h2>
  <p>
    When a route changes, Slice.js router triggers several events in sequence:
  </p>
  <ol>
    <li>Navigation is triggered (link click, browser back/forward, or programmatic navigation)</li>
    <li><strong>beforeEach</strong> guard is called (if defined)</li>
    <li>The previous component is removed from the DOM</li>
    <li>The new component is built and inserted into the DOM</li>
    <li>Component <code>init()</code> method is called (if exists)</li>
    <li><strong>afterEach</strong> hook is called (if defined)</li>
  </ol>

  <h2 id="route-best-practices">Best Practices for Routing</h2>
  <ul>
    <li>Organize your routes logically, grouping related routes together</li>
    <li>Use the most specific component for your routing needs</li>
    <li>Keep route parameters simple and descriptive</li>
    <li>Add a catch-all 404 route to handle unmatched paths</li>
    <li>Use standard anchor elements for navigation links</li>
    <li>Define navigation guards before starting the router for authentication</li>
    <li>Use route metadata to store configuration rather than hardcoding logic</li>
    <li>Take advantage of dynamic route management when needed</li>
  </ul>

  <h2 id="faq">Frequently Asked Questions</h2>
  <div class="faq-section"></div>
</div>